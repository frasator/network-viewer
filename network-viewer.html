<script src="../stevia-elements/src/manager/stevia-manager.js"></script>
<script src="../FileSaver.js/FileSaver.min.js"></script>

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-list/iron-list.html">

<script src="../stevia-elements/src/utils/utils.js"></script>
<script src="../stevia-elements/src/utils/svg.js"></script>

<script src="../d3/d3.min.js"></script>
<script src="../cytoscape/dist/cytoscape.min.js"></script>
<script src="../pako/dist/pako.min.js"></script>

<script src="../js-xlsx/dist/jszip.js"></script>
<script src="../js-xlsx/dist/xlsx.min.js"></script>

<script src="../cookies-js/dist/cookies.min.js"></script>
<script src="../crypto-js/core.js"></script>
<script src="../crypto-js/sha1.js"></script>
<script src="../crypto-js/md5.js"></script>
<script src="../highcharts-release/adapters/standalone-framework.js"></script>
<script src="../highcharts-release/highcharts.js"></script>

<link rel="import" href="src/nv-graph.html">

<script src="src/js/graph/point.js"></script>
<script src="src/js/graph/edge.js"></script>
<script src="src/js/graph/vertex.js"></script>
<!--<script src="src/js/graph/default-vertex-renderer.js"></script>-->
<script src="src/js/graph/circos-vertex-renderer.js"></script>
<script src="src/js/graph/default-edge-renderer.js"></script>
<script src="src/js/graph/graph-layout.js"></script>

<script src="src/js/data/attribute-network-data-adapter.js"></script>
<script src="src/js/data/json-network-data-adapter.js"></script>
<script src="src/js/data/sif-network-data-adapter.js"></script>
<script src="src/js/data/text-network-data-adapter.js"></script>
<script src="src/js/data/xlsx-network-data-adapter.js"></script>

<script src="../stevia-elements/src/utils/data-source/data-source.js"></script>
<script src="../stevia-elements/src/utils/data-source/file-data-source.js"></script>
<script src="../stevia-elements/src/utils/data-source/string-data-source.js"></script>

<link rel="import" href="../stevia-elements/src/stv-panel.html">
<link rel="import" href="../stevia-elements/src/dropdown/stv-dropdown.html">
<link rel="import" href="../stevia-elements/src/stv-color-picker.html">
<link rel="import" href="../stevia-elements/src/stv-color-menu.html">
<link rel="import" href="../stevia-elements/src/stv-select-box.html">
<link rel="import" href="../stevia-elements/src/stv-select.html">
<link rel="import" href="../stevia-elements/src/table/stv-table.html">
<link rel="import" href="../stevia-elements/src/form/stv-file-origin.html">
<link rel="import" href="../stevia-elements/src/stv-dialog/stv-dialog.html">


<!-- analysis -->
<link rel="import" href="src/analysis/nv-communities-structure-detection.html">
<link rel="import" href="src/analysis/nv-topological-study.html">


<!-- attributes -->
<link rel="import" href="src/attributes/nv-attribute-edit.html">
<link rel="import" href="src/attributes/nv-cellbase-diseases-import.html">
<link rel="import" href="src/attributes/nv-cellbase-drugs-import.html">
<link rel="import" href="src/attributes/nv-cellbase-functionalities-import.html">
<link rel="import" href="src/attributes/nv-cellbase-xref-import.html">

<link rel="import" href="src/attributes/render-settings/nv-attribute-node-render.html">
<link rel="import" href="src/attributes/render-settings/nv-attribute-edge-render.html">
<link rel="import" href="src/attributes/render-settings/nv-attribute-render-number-table.html">
<link rel="import" href="src/attributes/render-settings/nv-attribute-render-color-table.html">
<link rel="import" href="src/attributes/render-settings/nv-attribute-render-select-table.html">


<!-- file -->
<link rel="import" href="src/file/nv-attribute-network-file-open.html">
<!-- <link rel="import" href="src/file/nv-session-manager.html"> -->
<link rel="import" href="src/file/nv-sif-network-file-open.html">
<link rel="import" href="src/file/nv-text-network-file-open.html">
<link rel="import" href="src/file/nv-xlsx-network-file-open.html">


<!-- network -->
<link rel="import" href="src/network/nv-configure-concentric.html">
<link rel="import" href="src/network/nv-configure-force-directed.html">
<link rel="import" href="src/network/nv-configure-spring-embedder.html">
<link rel="import" href="src/network/nv-intact-import.html">
<link rel="import" href="src/network/nv-kegg.html">
<link rel="import" href="src/network/nv-network-edit.html">
<link rel="import" href="src/network/nv-reactome.html">
<link rel="import" href="src/network/nv-select-filter.html">


<link rel="import" href="src/nv-bar.html">
<link rel="import" href="src/nv-edition-bar.html">
<link rel="import" href="src/nv-background-bar.html">
<link rel="import" href="src/nv-layout.html">
<link rel="import" href="src/nv-status-bar.html">
<link rel="import" href="src/nv-tool-bar.html">


<script src="../stevia-elements/src/manager/cellbase-manager.js"></script>
<script src="../stevia-elements/src/manager/stevia-manager.js"></script>

<dom-module id="network-viewer">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: relative;
            background-color: #FFFFFF;
            font-size: 13px;
            font-family: 'Lato', 'Helvetica Neue', Helvetica, Arial, 'sans-serif' !important;
            height: 100%;
            width: 100%;
        }

        .left-side {
            top: 94px;
            left: 0px;
            position: absolute;
        }

        .right-side {
            top: 94px;
            right: 0px;
            position: absolute;
        }

        nv-layout {
            height: calc(100% - 126px);
        }

        .stv-context {
            min-width: 200px;
            cursor: pointer;
        }

        .attr-context {
            font-size: 13px;
        }

        .attrkey {
            color: #888888;
        }

        .attrvalue {}

        .link {
            text-decoration: none;
            color: inherit;
        }

        .link:hover {
            text-decoration: underline;
        }

        .link:visited {
            color: inherit;
        }

        #sessionManager,
        #sessionManagerPanel {
            width: 500px;
        }

        div.dropdown ul li:hover,
        ul.context li:hover {
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }
    </style>
    <template>

        <nv-bar id="nvbar" lite="{{lite}}" hide-external="{{hideExternal}}" hidden$="{{hideBar}}" columns="{{vertexColumns}}" on-session-start="handleSessionStartMenu" on-session-open="handleSessionOpenMenu" on-session-save="handleSessionSaveMenu" on-session-manage="handleSessionManageMenu" on-import-sif="handleImportSifMenu" on-import-text="handleImportTextMenu" on-import-xlsx="handleImportXlsxMenu" on-import-node-attributes="handleImportNodeAttrMenu" on-import-edge-attributes="handleImportEdgeAttrMenu" on-export-sif="handleExportSifMenu" on-export-svg="handleExportSvgMenu" on-export-png="handleExportPngMenu" on-export-node-attributes="handleExportNodeAttrMenu" on-export-edge-attributes="handleExportEdgeAttrMenu" on-nodes-select-all="handleSelectMenu" on-nodes-select-first-neighbourhood="handleSelectMenu" on-nodes-select-invert="handleSelectMenu" on-edges-select-all="handleSelectMenu" on-edges-select-adjacent="handleSelectMenu" on-network-select-all="handleSelectMenu" on-layout="handleLayoutMenu" on-network-edit="handleNetworkEditMenu" on-nodes-edit="handleNodesEditMenu" on-edges-edit="handleEdgesEditMenu" on-nodes-filter="handleNodesFilterMenu" on-edges-filter="handleEdgesFilterMenu" on-cellbase="handleCellbaseMenu" on-node-simple-rendering="handleNodeSimpleRenderingMenu" on-node-list-rendering="handleNodeListRenderingMenu" on-edge-simple-rendering="handleEdgeSimpleRenderingMenu" on-reactome="handleReactomeMenu" on-kegg="handleKeggMenu" on-intact="handleIntactMenu" on-communities-structure-detection="handleCommunitiesMenu" on-topological-study="handleTopologicalMenu" on-reactome-fi-microarray="handleReactomeFiMenu" on-example="handleLoadExampleMenu" on-save="handleSave" on-drugs="handleDrugsMenu" on-diseases="handleDiseasesMenu" on-functionalities="handleFunctionalitiesMenu">
        </nv-bar>

        <nv-tool-bar lite="{{lite}}" hidden$="{{hideToolBar}}" background-color="{{backgroundColor}}" mode="{{mode}}" zoom="{{zoom}}" on-layoutchange="handleLayoutChange" on-selectchange="handleSelectChange" on-rotatechange="handleRotateChange" on-reset-zoom="handleResetZoom" on-center-network="handleCenterNetwork" on-undo="undoAction" on-redo="redoAction">
        </nv-tool-bar>

        <nv-edition-bar id="editionBar" hidden$="{{isEditionBarHidden(hideEditionBar, mode)}}" selection-color="{{vertexDefaults.selectionColor}}" vertex-columns="{{vertexColumns}}" edge-columns="{{edgeColumns}}" on-vertexeditionbar="handleVertexEditionBar" on-edgeeditionbar="handleEdgeEditionBar" on-vertexsearch="handleVertexSearch" on-vertexnamefield="handleVertexNameField" on-edgesearch="handleEdgeSearch" on-edgenamefield="handleEdgeNameField">
        </nv-edition-bar>

        <nv-background-bar id="backgroundBar" back-canvas="{{backCanvas}}" hidden$="{{isBackgroundBarHidden(hideEditionBar, mode)}}">
        </nv-background-bar>

        <nv-layout id="networkLayout" back-canvas="{{backCanvas}}" hide-mini-map="{{hideMiniMap}}" mode="{{mode}}" scale="{{scale}}" tx="{{center.x}}" ty="{{center.y}}" zoom="{{zoom}}" graph="{{graph}}" background-color="{{backgroundColor}}" on-createvertex="handleCreateVertex" on-selectvertex="handleSelectVertex" on-moveselectedvertices="handleMoveSelectedVertices" on-selectarea="handleSelectArea" on-createedge="handleCreateEdge" on-removevertex="handleRemoveVertex" on-removeedge="handleRemoveEdge" on-leftclickvertex="handleLeftClickVertex" on-selectedge="handleSelectEdge" on-leftclickedge="handleLeftClickEdge" on-rightclickvertex="handleRightClickVertex" on-rightclickedge="handleRightClickEdge" on-rightclickbackgroundimage="handleRightClickBackgroundImage" on-hoververtex="handleHoverVertex" on-hoveredge="handleHoverEdge">
        </nv-layout>

        <nv-status-bar hidden$="{{hideStatusBar}}" last-loaded-file-name="{{lastLoadedFileName}}" vertices="{{vertices}}" edges="{{edges}}" selected-vertices="{{selectedVertices}}" selected-edges="{{selectedEdges}}" selection-color="{{vertexDefaults.selectionColor}}">
        </nv-status-bar>

        <div class="right-side">
            <stv-panel collapsible movable closable id="nodeRenderPanel">
                <div class="header">
                    Node visualization settings
                </div>
                <nv-attribute-node-render class="container" id="nodeRender" columns="{{vertexColumns}}" items="{{vertices}}" defaults="{{vertexDefaults}}" visual-sets="{{vertexVisualSets}}" on-labelAttribute="handleVertexDefaultLabelAttribute" on-labelsize="handleVertexDefaultLabelSize" on-labelpositionx="handleVertexDefaultLabelPositionX" on-labelpositiony="handleVertexDefaultLabelPositionY" on-opacity="handleVertexDefaultOpacity" on-shape="handleVertexDefaultShape" on-color="handleVertexDefaultColor" on-strokecolor="handleVertexDefaultStrokeColor" on-size="handleVertexDefaultSize" on-strokesize="handleVertexDefaultStrokeSize" on-area="handleVertexDefaultArea" on-strokeArea="handleVertexDefaultStrokeArea" on-xattribute="handleVertexDefaultXAttribute" on-yattribute="handleVertexDefaultYAttribute">
                </nv-attribute-node-render>
            </stv-panel>

            <stv-panel collapsible movable closable id="edgeRenderPanel">
                <div class="header">
                    Edge visualization settings
                </div>
                <nv-attribute-edge-render class="container" id="edgeRender" columns="{{edgeColumns}}" items="{{edges}}" defaults="{{edgeDefaults}}" visual-sets="{{edgeVisualSets}}" on-labelattribute="handleEdgeDefaultLabelAttribute" on-labelsize="handleEdgeDefaultLabelSize" on-opacity="handleEdgeDefaultOpacity" on-shaft="handleEdgeDefaultShaft" on-shape="handleEdgeDefaultShape" on-bidirectional="handleEdgeDefaultBidirectional" on-color="handleEdgeDefaultColor" on-size="handleEdgeDefaultSize">
                </nv-attribute-edge-render>
            </stv-panel>
        </div>

        <div class="left-side">

            <stv-panel hidden collapsible fixed movable closable id="nodeSelectFilterPanel">
                <div class="header">
                    Select nodes by attributes
                </div>
                <nv-select-filter class="container" id="nodeSelectFilter" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" filters="{{vertexDefaults.filters}}" on-invert-selection="selectVerticesInvert" on-remove-selected="removeSelectedVertices">
                </nv-select-filter>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="edgeSelectFilterPanel">
                <div class="header">
                    Select edges by attributes
                </div>
                <nv-select-filter class="container" id="edgeSelectFilter" columns="{{edgeColumns}}" items="{{edges}}" selected="{{selectedEdges}}" filters="{{edgeDefaults.filters}}" on-invert-selection="selectEdgesInvert" on-remove-selected="removeSelectedEdges">
                </nv-select-filter>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable id="networkEditPanel">
                <div class="header">
                    Edit Network
                </div>
                <nv-network-edit class="container" id="networkEdit" selected-vertices="{{selectedVertices}}" selected-edges="{{selectedEdges}}" vertices="{{vertices}}" edges="{{edges}}" on-remove-selected-edges="removeSelectedEdges" on-remove-selected-vertices="removeSelectedVertices" on-add-edge="handleNetworkEditAddEdge" on-add-vertex="handleNetworkEditAddVertex">
                </nv-network-edit>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable expandible constraint id="nodeAttributeEditPanel">
                <div class="header">
                    Edit and filter node attributes
                </div>
                <nv-attribute-edit class="container" id="nodeAttributeEdit" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" on-selectedchange="handleAttributeEditVertexSelectedChange" on-selectall="selectAllVertices" on-deselectall="deselectAllVertices" on-update-row="handleVerticesUpdateRow" type="node">
                </nv-attribute-edit>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="edgeAttributeEditPanel">
                <div class="header">
                    Edit and filter edge attributes
                </div>
                <nv-attribute-edit class="container" id="edgeAttributeEdit" columns="{{edgeColumns}}" items="{{edges}}" selected="{{selectedEdges}}" on-selectedchange="handleAttributeEditEdgeSelectedChange" on-selectall="selectAllEdges" on-deselectall="deselectAllEdges" on-update-row="handleEdgesUpdateRow" type="edge">
                </nv-attribute-edit>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable id="cellbaseXrefImportPanel">
                <div class="header">
                    Import external references
                </div>
                <nv-cellbase-xref-import id="cellbaseXrefImport" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns" hide-external="{{hideExternal}}">
                </nv-cellbase-xref-import>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="functionalitiesPanel">
                <div class="header">
                    Import functional annotations
                </div>
                <nv-cellbase-functionalities-import id="functionalities" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns" hide-external="{{hideExternal}}">
                </nv-cellbase-functionalities-import>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="drugsPanel">
                <div class="header">
                    Import drugs by gene
                </div>
                <nv-cellbase-drugs-import id="drugs" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns" on-apply-color="handleApplyDrugsColor" on-apply-multicolor="handleApplyDrugsMulticolor" hide-external="{{hideExternal}}">
                </nv-cellbase-drugs-import>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="diseasesPanel">
                <div class="header">
                    Import diseases by gene
                </div>
                <nv-cellbase-diseases-import id="drugs" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns" on-apply-multicolor="handleApplyDiseasesMulticolor" hide-external="{{hideExternal}}">
                </nv-cellbase-diseases-import>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable id="intactImportPanel">
                <div class="header">
                    Find interactions
                </div>
                <nv-intact-import id="intactImport" class="container" items="{{vertices}}" columns="{{vertexColumns}}" selected="{{selectedVertices}}" on-graph="handleIntactGraph" hide-external="{{hideExternal}}">
                </nv-intact-import>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="reactomeImportPanel">
                <div class="header">
                    Reactome import
                </div>
                <nv-reactome id="reactomeImport" class="container" on-graph="handleReactomeGraph">
                </nv-reactome>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable id="keggImportPanel">
                <div class="header">
                    Kegg import
                </div>
                <nv-kegg id="keggImport" class="container" on-graph="handleKeggGraph" hide-external="{{hideExternal}}">
                </nv-kegg>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="communitiesStructureDetectionPanel">
                <div class="header">
                    Network analysis: Community structure detection
                </div>
                <nv-communities-structure-detection id="communitiesStructureDetection" items="{{vertices}}" columns="{{vertexColumns}}" graph="{{graph}}" on-community="handleCommunityAttributes" on-apply-community="handleApplyCommunity" class="container">
                </nv-communities-structure-detection>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable id="topologicalStudyPanel">
                <div class="header">
                    Network analysis: Topological study
                </div>
                <nv-topological-study id="topologicalStudy" items="{{vertices}}" columns="{{vertexColumns}}" graph="{{graph}}" on-topological="handleTopologicalAttributes" class="container">
                </nv-topological-study>
            </stv-panel>


            <stv-panel hidden collapsible fixed movable closable id="configureForceDirectedPanel">
                <div class="header">
                    Force directed layout configuration
                    <a class="link" style="margin-left: 15px;" target="_blank" href="https://github.com/mbostock/d3/wiki/Force-Layout">
                        <i class="fa fa-external-link"></i> about
                    </a>
                </div>
                <nv-configure-force-directed id="configureForceDirected" class="container" vertex-columns="{{vertexColumns}}" edge-columns="{{edgeColumns}}" on-ok="handleForceDirectedConfig">
                </nv-configure-force-directed>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="configureCosePanel">
                <div class="header">
                    Compound spring embedder layout configuration
                    <a class="link" style="margin-left: 15px;" target="_blank" href="http://js.cytoscape.org/#layouts/cose">
                        <i class="fa fa-external-link"></i> about
                    </a>
                </div>
                <nv-configure-spring-embedder id="configureCose" class="container" vertex-columns="{{vertexColumns}}" edge-columns="{{edgeColumns}}" on-ok="handleCoseConfig">
                </nv-configure-spring-embedder>
            </stv-panel>

            <stv-panel hidden collapsible fixed movable closable id="configureConcentricPanel">
                <div class="header">
                    Concentric layout configuration
                    <a class="link" style="margin-left: 15px;" target="_blank" href="http://js.cytoscape.org/#layouts/concentric">
                        <i class="fa fa-external-link"></i> about
                    </a>
                </div>
                <nv-configure-concentric id="configureConcentric" class="container" vertex-columns="{{vertexColumns}}" edge-columns="{{edgeColumns}}" on-ok="handleConcentricConfig">
                </nv-configure-concentric>
            </stv-panel>


            <!--Menu file-->
            <div style="position:fixed;z-index:10">
                <stv-panel modal fixed style hidden="{{!computeSelectedMenu(selectedMenu, 'import-sif')}}">
                    <div class="header">
                        Import a network SIF file
                    </div>
                    <nv-sif-network-file-open id="importSif" class="container" selected-menu="{{selectedMenu}}" on-graph="handleImportSif">
                    </nv-sif-network-file-open>
                </stv-panel>


                <stv-panel modal fixed hidden="{{!computeSelectedMenu(selectedMenu, 'import-text')}}">
                    <div class="header">
                        Import a network Text file
                    </div>
                    <nv-text-network-file-open id="importText" class="container" selected-menu="{{selectedMenu}}" on-graph="handleImportText">
                    </nv-text-network-file-open>
                </stv-panel>


                <stv-panel modal fixed hidden="{{!computeSelectedMenu(selectedMenu, 'import-xlsx')}}">
                    <div class="header">
                        Import a network XLSX file
                    </div>
                    <nv-xlsx-network-file-open id="importXLSX" class="container" selected-menu="{{selectedMenu}}" on-graph="handleImportText">
                    </nv-xlsx-network-file-open>
                </stv-panel>


                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-node-attributes')}}">
                    <stv-panel modal fixed>
                        <div class="header">
                            Import Node attributes file
                        </div>
                        <nv-attribute-network-file-open class="container" selected-menu="{{selectedMenu}}" on-open="handleImportNodeAttr">
                        </nv-attribute-network-file-open>
                    </stv-panel>
                </template>

                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-edge-attributes')}}">
                    <stv-panel modal fixed>
                        <div class="header">
                            Import edge attributes file
                        </div>
                        <nv-attribute-network-file-open class="container" selected-menu="{{selectedMenu}}" on-open="handleImportEdgeAttr">
                        </nv-attribute-network-file-open>
                    </stv-panel>
                </template>
            </div>


        </div>

        <ul id="imagecontextmenu" class="stv-context" hidden>
            <li on-click="handleContextRemoveBackGroundImage">Remove</li>
        </ul>

        <ul id="vertexcontextmenu" class="stv-context" hidden>
            <li on-click="handleContextRemoveVertex">Delete node</li>
            <li on-click="handleContextRemoveSelectedVertices" hidden$="{{checkContextOneSelected(selectedVertices.length)}}">Delete selected nodes</li>
            <li data-divider></li>
            <li on-click="handleContextSelectVerticesNeighbour">Select first neighbour nodes</li>
            <li on-click="handleContextSelectEdgesNeighbour">Select Adjacent edges</li>
            <li data-divider></li>
            <li data-text>
                <u>Attributes</u>
            </li>
            <li data-text>
                <div class="attr-context" class="vertical layout">
                    <template is="dom-repeat" items="{{_lastContextVertexAttributes}}" as="attr">
                        <div data-text>
                            <span class="attrkey">{{attr.key}}</span>:
                            <span class="attrvalue">{{attr.value}}</span>
                        </div>
                    </template>
                </div>
            </li>
        </ul>
        <ul id="edgecontextmenu" class="stv-context" hidden>
            <li on-click="handleContextRemoveEdge">Delete edge</li>
            <li on-click="handleContextRemoveSelectedEdges" hidden$="{{checkContextOneSelected(selectedEdges.length)}}">Delete selected edges</li>
            <li data-divider></li>
            <li data-text>
                <u>Attributes</u>
            </li>
            <li data-text>
                <div class="attr-context" class="vertical layout">
                    <template is="dom-repeat" items="{{_lastContextEdgeAttributes}}" as="attr">
                        <div data-text>
                            <span class="attrkey">{{attr.key}}</span>:
                            <span class="attrvalue">{{attr.value}}</span>
                        </div>
                    </template>
                </div>
            </li>
        </ul>

        <nv-graph id="graph" vertices="{{vertices}}" edges="{{edges}}"></nv-graph>
        <stv-dropdown id="nodeTooltip" no-min-width>
            <ul data-menu>
                <div id="nodeTooltipContent" data-nohide style="padding:10px;">
                </div>
            </ul>
        </stv-dropdown>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'network-viewer',
        properties: {
            mode: {
                type: String,
                value: 'select'
            },
            backCanvas: {
                type: Object,
            },
            lite: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            hideExternal: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            hideBar: {
                type: Boolean,
                value: false
            },
            hideToolBar: {
                type: Boolean,
                value: false,
                observer: 'computeHeight'
            },
            hideEditionBar: {
                type: Boolean,
                value: false,
                observer: 'computeHeight'
            },
            hideStatusBar: {
                type: Boolean,
                value: false,
                observer: 'computeHeight'
            },
            hideNodeRender: {
                type: Boolean,
                value: false,
                observer: 'handleHideNodeRender'
            },
            hideEdgeRender: {
                type: Boolean,
                value: false,
                observer: 'handleHideEdgeRender'
            },
            hideMiniMap: {
                type: Boolean,
                value: false
            },
            disableContextMenu: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            disableTooltip: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            userData: {
                type: Object,
            },
            zoom: {
                type: Number,
                value: 25
            },
            backgroundColor: {
                type: String,
                value: '#FFF'
            },
            vertices: {
                type: Array,
                notify: true,
                value: function() {
                    return []
                }
            },
            edges: {
                type: Array,
                notify: true,
                value: function() {
                    return []
                }
            },
            scale: {
                type: Number,
            },
            center: {
                type: Object,
                value: function() {
                    return {
                        x: 0,
                        y: 0
                    }
                }
            },
            vertexColumns: {
                type: Array,
                notify: true
            },
            edgeColumns: {
                type: Array,
                notify: true
            },
            selectedVertices: {
                type: Array,
                notify: true
            },
            selectedEdges: {
                type: Array,
                notify: true
            },
            selectedMenu: {
                type: String,
                value: ''
            },

            lastLoadedFileName: {
                type: String,
                value: ''
            },
            serializeVersion: {
                type: String,
                value: 'v3'
            },
            saveInProgress: {
                type: Boolean,
                value: false
            },
            bioformats: {
                type: Array
            },
            projects: {
                type: Array
            },

            actionStack: {
                type: Array,
                value: function() {
                    return []
                }
            },
            actionStackPointer: {
                type: Number,
                value: 0
            },
            lastContextVertex: {
                type: Object
            },
            lastContextEdge: {
                type: Object
            },
            lastHoverVertex: {
                type: Object
            }
        },
        _computingHeigth: false,
        observers: [
            'selectedVerticesChanged(selectedVertices.splices)',
            'selectedEdgesChanged(selectedEdges.splices)',
            'vertexSelectionColorChanged(vertexDefaults.selectionColor)'
        ],
        checkContextOneSelected: function(length) {
            return length < 2;
        },
        ready: function() {
            var me = this;

            if (this.domHost != null && this.domHost.tagName == 'CELL-MAPS-ELEMENT') {
                this.cellMaps = this.domHost;
            }

            this.serializeKey = 'NV_CURRENT_SESSION' + this.serializeVersion;

            this.graph = this.$.graph;
            this.set('selectedVertices', []);
            this.set('selectedEdges', []);

            this.computeHeight();

            document.body.addEventListener('click', function(e) {
                me._hideVertexContextMenu();
                me._hideEdgeContextMenu();
                me._hideImageContextMenu();
            });
            this._init();
        },
        computeHeight: function() {
            this.async(function() {
                var h = 126;
                if (this.hideBar) {
                    h -= 30;
                }
                if (this.hideToolBar) {
                    h -= 32;
                }
                if (this.hideEditionBar) {
                    h -= 32;
                }
                if (this.hideStatusBar) {
                    h -= 32;
                }
                this.$.networkLayout.style.height = "calc(100% - " + h + "px)";
            });
        },
        handleHideNodeRender: function(neo, old) {
            // console.log('handleHideNodeRender');
            if (neo == true) {
                this.$.nodeRenderPanel.hide();
            } else if (neo == false) {
                this.$.nodeRenderPanel.show();
            }
        },
        handleHideEdgeRender: function(neo, old) {
            // console.log('handleHideEdgeRender');
            if (neo == true) {
                this.$.edgeRenderPanel.hide();
            } else if (neo == false) {
                this.$.edgeRenderPanel.show();
            }
        },
        isEditionBarHidden: function(hideEditionBar, mode) {
            return hideEditionBar || mode == 'selectbackground';
        },
        isBackgroundBarHidden: function(hideEditionBar, mode) {
            return hideEditionBar || mode != 'selectbackground';
        },
        _init: function() {
            this.resetZoom();
            this.lastLoadedFileName = "";
            this.backgroundColor = '#FFF';
            this.vertexDefaults = {
                shape: 'circle',
                size: 40,
                //            color: '#9fc6e7',
                color: '#FFFFFF',
                strokeSize: 2,
                //            strokeColor: '#9fc6e7',
                strokeColor: '#888888',
                area: 1,
                strokeArea: 1,
                opacity: 1,
                labelSize: 12,
                labelColor: '#111111',
                labelPositionX: 0,
                labelPositionY: 0,
                labelAttribute: 'id',
                xAttribute: '',
                yAttribute: '',
                selectionColor: '#da6d1f',
                filters: []
            };
            this.edgeDefaults = {
                shape: 'directed',
                shaft: 'solid',
                bidirectional: 'false',
                size: 1,
                color: '#888888',
                //            color: '#cccccc',
                opacity: 1,
                labelSize: 0,
                labelColor: '#111111',
                labelAttribute: 'relation',
                filters: []
            };
            this.vertexVisualSets = {
                labelSize: null,
                opacity: null,
                shape: null,
                color: null,
                strokeColor: null,
                size: null,
                strokeSize: null
            };
            this.edgeVisualSets = {
                labelSize: null,
                opacity: null,
                shape: null,
                shaft: null,
                bidirectional: null,
                color: null,
                size: null
            };
            if (this.$) {
                var key;
                for (key in this.vertexVisualSets) {
                    if (this.$.nodeRender) {
                        this.$.nodeRender.$[key].clean();
                    }
                }
                for (key in this.edgeVisualSets) {
                    if (this.$.edgeRender) {
                        this.$.edgeRender.$[key].clean();
                    }
                }
            }
            this._createAttrColumns();
        },
        _createAttrColumns: function() {
            var me = this;
            var vertexColumns = [];
            var edgeColumns = [];
            vertexColumns.push({
                name: "id",
                title: "Id",
                type: "text",
                editable: false,
                formula: function(row) {
                    return row.attributes[this.name];
                }
            });
            vertexColumns.push({
                name: "x",
                title: "x",
                type: "text",
                width: 70,
                formula: function(row) {
                    return parseFloat(row.position[this.name].toFixed(2));
                },
                editFormula: function(row, newVal) {
                    row.position[this.name] = parseFloat(newVal);
                    me.setVertexCoords(row.id);
                }
            });
            vertexColumns.push({
                name: "y",
                title: "y",
                type: "text",
                width: 70,
                formula: function(row) {
                    return parseFloat(row.position[this.name].toFixed(2));
                },
                editFormula: function(row, newVal) {
                    row.position[this.name] = parseFloat(newVal);
                    me.setVertexCoords(row.id);
                }
            });
            vertexColumns.push({
                name: "name",
                title: "Name",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                },
                editFormula: function(row, newVal) {
                    row.attributes[this.name] = newVal;
                }
            });
            edgeColumns.push({
                name: "id",
                title: "Id",
                type: "text",
                editable: false,
                formula: function(row) {
                    return row.attributes[this.name];
                }
            });
            edgeColumns.push({
                name: "name",
                title: "Name",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                },
                editFormula: function(row, newVal) {
                    row.attributes[this.name] = newVal;
                }
            });
            edgeColumns.push({
                name: "relation",
                title: "Relation",
                type: "text",
                formula: function(row) {
                    return row.attributes["relation"];
                },
                editFormula: function(row, newVal) {
                    row.attributes[this.name] = newVal;
                }
            });
            this.set('vertexColumns', vertexColumns);
            this.set('edgeColumns', edgeColumns);
        },
        _restoreColumns: function(jsonColumns) {
            var me = this;
            for (var i = 0; i < jsonColumns.length; i++) {
                var column = jsonColumns[i];
                if (column.name == 'x' || column.name == 'y') {
                    column.formula = function(row) {
                        return parseFloat(row.position[this.name].toFixed(2));
                    }
                    column.editFormula = function(row, newVal) {
                        row.position[this.name] = parseFloat(newVal);
                        me.setVertexCoords(row.id);
                    }
                } else {
                    column.formula = function(row) {
                        return row.attributes[this.name];
                    }
                    column.editFormula = function(row, newVal) {
                        row.attributes[column.name] = newVal;
                    }
                }
            }
        },
        handleSave: function() {
            this.saveLocalStorage();
        },
        startOver: function() {
            this.deleteLocalStorage();
            this._init();
            this.$.networkLayout.clean();
            this.graph.clean();
            this.saveLocalStorage();
            this.fire('startover');
        },
        resetZoom: function() {
            this.zoom = 25;
        },
        centerNetwork: function() {
            if (this.vertices.length > 0) {
                this.$.networkLayout.centerNetwork();
            } else {
                this.zoom = 25;
                this.refreshGraphView();
            }
            this.addActionStack();
        },
        adjustWidthNetwork: function() {
            this.$.networkLayout.adjustWidthNetwork();
            this.addActionStack();
        },
        adjustHeightNetwork: function() {
            this.$.networkLayout.adjustHeightNetwork();
            this.addActionStack();
        },


        loadLocalStorage: function() {
            var item = localStorage.getItem(this.serializeKey);
            if (item !== null && item !== "null") {
                try {
                    this.loadJSON(JSON.parse(pako.ungzip(localStorage.getItem(this.serializeKey), {
                        to: 'string'
                    })));
                } catch (e) {
                    this.deleteLocalStorage();
                    return false;
                }
                return true;
            }
            return false;
        },
        saveLocalStorage: function() {
            if (this.saveInProgress == false) {
                this.saveInProgress = true;
                localStorage.setItem(this.serializeKey, pako.gzip(JSON.stringify(this), {
                    to: 'string'
                }));
                this.saveInProgress = false;
            } else {
                console.log("Save is already in progress");
            }
        },
        deleteLocalStorage: function() {
            //Clean OLD
            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (key.indexOf('NETWORKVIEWER') != -1) {
                    localStorage.removeItem(key);
                }
            }

            localStorage.setItem(this.serializeKey, null);
            localStorage.removeItem(this.serializeKey);
        },
        undoAction: function() {
            this.actionStackPointer += 1;
            var gzip;
            if (this.actionStackPointer <= 10) {
                gzip = this.actionStack[this.actionStackPointer];
            }
            if (gzip != null) {
                this.loadJSON(JSON.parse(pako.ungzip(gzip, {
                    to: 'string'
                })), true);
            } else {
                this.actionStackPointer -= 1;
            }
        },
        redoAction: function() {
            this.actionStackPointer -= 1;
            var gzip;
            if (this.actionStackPointer >= 0) {
                gzip = this.actionStack[this.actionStackPointer];
            }
            if (gzip != null) {
                this.loadJSON(JSON.parse(pako.ungzip(gzip, {
                    to: 'string'
                })), true);
            } else {
                this.actionStackPointer += 1;
            }
        },
        addActionStack: function() {
            var gzip = pako.gzip(JSON.stringify(this), {
                to: 'string'
            });
            var length = this.actionStack.unshift(gzip);
            this.actionStackPointer = 0;
            if (length > 10) {
                this.actionStack.pop();
            }
            this.$.networkLayout.updateMini();
        },

        loadJSON: function(o, notAddActionStack) {
            var me = this;
            this.startOver();
            //Version fix  selectionColor
            if (o.vertexDefaults.selectionColor == null) {
                o.vertexDefaults.selectionColor = this.vertexDefaults.selectionColor;
            }
            //Version Fix filters
            if (o.vertexDefaults.filters == null) {
                o.vertexDefaults.filters = this.vertexDefaults.filters;
            }
            if (o.edgeDefaults.filters == null) {
                o.edgeDefaults.filters = this.edgeDefaults.filters;
            }

            this.backgroundColor = o.backgroundColor;

            //            var graph = new NvGraph;
            //            graph.fromJSON(o.graph);

            this.graph.fromJSON(o.graph);

            this._createAttrColumns();
            this._restoreColumns(o.vertexColumns);
            this._restoreColumns(o.edgeColumns);

            this._addColumns(o.vertexColumns, 'vertexColumns');
            this._addColumns(o.edgeColumns, 'edgeColumns');

            this.vertexDefaults = o.vertexDefaults;
            this.edgeDefaults = o.edgeDefaults;
            this.vertexVisualSets = o.vertexVisualSets;
            this.edgeVisualSets = o.edgeVisualSets;

            this.refreshGraphView();

            this.saveLocalStorage();

            this.setVertexDefaultLabelAttribute(this.vertexDefaults.labelAttribute);
            this.setEdgeDefaultLabelAttribute(this.edgeDefaults.labelAttribute);

            this.resetZoom();
            this.set('center.x', o.center.x);
            this.set('center.y', o.center.y);
            this.resetZoom();
            this.zoom = o.zoom;

            this.backCanvas.loadFromJSON(o.background, function(e) {
                me.backCanvas.renderAll();
                me.saveLocalStorage();
            });
            //backward compatibility
            if (o.backgroundImages != null) {
                for (var i = 0, li = o.backgroundImages.length; i < li; i++) {
                    this.$.backgroundBar.addBackgroundImage(o.backgroundImages[i], false, function() {
                        me.saveLocalStorage();
                    });
                }
            }
            this.saveLocalStorage();

            if (notAddActionStack !== true) {
                this.addActionStack();
            }
        },

        toJSON: function() {
            return {
                zoom: this.zoom,
                backgroundColor: this.backgroundColor,
                center: this.center,
                vertexDefaults: this.vertexDefaults,
                edgeDefaults: this.edgeDefaults,
                vertexVisualSets: this.vertexVisualSets,
                edgeVisualSets: this.edgeVisualSets,
                graph: this.graph,
                vertexColumns: this.vertexColumns,
                edgeColumns: this.edgeColumns,
                version: this.serializeVersion,
                background: this.backCanvas
            };
        },
        /** Display Properties - Attribute Handlers **/
        /** API **/
        setVertexDefaultLabelAttribute: function(attribute) {
            var vertex;
            for (var i = 0, l = this.graph.vertices.length; i < l; i++) {
                vertex = this.graph.vertices[i];
                vertex.renderer.setLabelContent(vertex.attributes[attribute]);
                this._updateEdgeCoords(vertex);
            }
        },
        selectVertexDefaultLabelAttribute: function(attribute) {
            this.vertexDefaults.labelAttribute = attribute;
            this.setVertexDefaultLabelAttribute(attribute);
        },
        setEdgeDefaultLabelAttribute: function(attribute) {
            var edge;
            for (var i = 0, l = this.graph.edges.length; i < l; i++) {
                edge = this.graph.edges[i];
                edge.renderer.setLabelContent(edge.attributes[attribute]);
            }
        },
        selectEdgeDefaultLabelAttribute: function(attribute) {
            this.vertexDefaults.labelAttribute = attribute;
            this.setEdgeDefaultLabelAttribute(attribute);
        },
        setVertexDefaultDisplayProperty: function(displayProperty, value) {
            var splitStr = ",";
            var visualSetEnabled = false;
            var visualSet = this.vertexVisualSets[displayProperty];
            if (visualSet != null && visualSet.enabled) {
                visualSetEnabled = true;
            }
            if (visualSetEnabled == false) {
                var vertex;
                for (var i = 0, l = this.vertices.length; i < l; i++) {
                    vertex = this.graph.vertices[i];
                    vertex.renderer.set(displayProperty, value);
                    this._updateEdgeCoords(vertex);
                }
            } else {
                if (visualSet.parse != 'list') {
                    var vertex, renderValue;
                    for (var i = 0, l = this.vertices.length; i < l; i++) {
                        vertex = this.graph.vertices[i];
                        renderValue = visualSet.matches[vertex.attributes[visualSet.attribute]];
                        if (renderValue != null) {
                            vertex.renderer.set(displayProperty, renderValue);
                        } else {
                            vertex.renderer.set(displayProperty, value);
                        }
                        this._updateEdgeCoords(vertex);
                    }
                } else {
                    var vertex, renderValue, renderValues, finalValues, value, values;
                    for (var i = 0, l = this.vertices.length; i < l; i++) {
                        vertex = this.graph.vertices[i];
                        value = vertex.attributes[visualSet.attribute];
                        if (value == null) {
                            value = "";
                        }
                        values = value.split(splitStr);
                        renderValues = [];
                        for (var j = 0; j < values.length; j++) {
                            renderValue = visualSet.matches[values[j]];
                            if (renderValue != null) {
                                renderValues.push(renderValue);
                            } else {
                                renderValues.push(value);
                            }
                        }
                        finalValues = renderValues;
                        //                            //TODO rework, this is a temporal fix
                        //                            if(displayProperty.indexOf("stroke") == -1){
                        //                                vertex.renderer.pieLabelText = rowValues;
                        //                            }else{
                        //                            }
                        //                            //TODO end
                        vertex.renderer.set(displayProperty, finalValues);
                        this._updateEdgeCoords(vertex);
                    }
                }
            }
            this.addActionStack();
        },
        setEdgeDefaultDisplayProperty: function(displayProperty, value) {
            var visualSetEnabled = false;
            var visualSet = this.edgeVisualSets[displayProperty];
            if (visualSet != null && visualSet.enabled) {
                visualSetEnabled = true;
            }
            var edge, finalValue, renderValue;
            for (var i = 0, l = this.edges.length; i < l; i++) {
                edge = this.edges[i];
                finalValue = value;
                if (visualSetEnabled) {
                    renderValue = visualSet.matches[edge.attributes[visualSet.attribute]];
                    if (renderValue != null) {
                        finalValue = renderValue;
                    }
                }
                edge.renderer.set(displayProperty, finalValue);
            }
            this.addActionStack();
        },
        setVertexDefaultPositionX: function(attribute, adjust, invertAxis) {
            adjust = (adjust == null) ? true : adjust;
            invertAxis = (invertAxis == null) ? false : invertAxis;
            // this._calculateVertexAttributeNormalization(attribute, "x", "width", adjust, invertAxis);
            this._setVertexPositionByAttribute(attribute, "x");
        },
        _setVertexPositionByAttribute: function(coordAttr, coord) {
            for (var i = 0; i < this.graph.vertices.length; i++) {
                vertex = this.graph.vertices[i];
                attributes = vertex.attributes;
                c = parseFloat(attributes[coordAttr]);
                if (!isNaN(c)) {
                    if (coord == "y") {
                        vertex.position[coord] = c * -1;
                    }
                    if (coord == "x") {
                        vertex.position[coord] = c;
                    }
                    this.setVertexCoords(vertex.id);
                }
            }
            this.centerNetwork();
        },
        _calculateVertexAttributeNormalization: function(coordAttr, coord, measure, adjust, invertAxis) {
            var margin = 100,
                midMargin = margin / 2;
            var max, min, c;
            var attributes, vertex;
            for (var i = 0; i < this.graph.vertices.length; i++) {
                vertex = this.graph.vertices[i];
                attributes = vertex.attributes;
                c = parseFloat(attributes[coordAttr]);
                if (!isNaN(c)) {
                    if (!max) {
                        max = c;
                        min = c;
                    }
                    max = Math.max(c, max);
                    min = Math.min(c, min);
                }
            }
            var range = (max === min) ? 1 : max - min;
            if (adjust == false) {
                measure = range;
            } else {
                measure = this.$.networkLayout.getBoundingClientRect()[measure] - margin;
            }
            var attributes, vertex, c;
            for (var i = 0; i < this.graph.vertices.length; i++) {
                vertex = this.graph.vertices[i];
                attributes = vertex.attributes;
                c = parseFloat(attributes[coordAttr]);
                c = (c - min) * measure / range;
                if (invertAxis) {
                    c = measure - c;
                }
                if (!isNaN(c)) {
                    vertex.position[coord] = c + midMargin;
                    vertex.renderer.move();
                    this._updateEdgeCoords(vertex);
                }
            }
        },
        setVertexDefaultPositionY: function(attribute, adjust, invertAxis) {
            adjust = (adjust == null) ? true : adjust;
            invertAxis = (invertAxis == null) ? true : invertAxis;
            // this._calculateVertexAttributeNormalization(attribute, "y", "height", adjust, invertAxis);
            this._setVertexPositionByAttribute(attribute, "y");
        },
        /** Handlers **/
        /* Vertex */
        handleVertexDefaultLabelAttribute: function() {
            this.setVertexDefaultLabelAttribute(this.vertexDefaults.labelAttribute);
        },
        handleVertexDefaultLabelSize: function() {
            this.setVertexDefaultDisplayProperty('labelSize', this.vertexDefaults.labelSize);
        },
        handleVertexDefaultLabelPositionX: function() {
            this.setVertexDefaultDisplayProperty('labelPositionX', this.vertexDefaults.labelPositionX);
        },
        handleVertexDefaultLabelPositionY: function() {
            this.setVertexDefaultDisplayProperty('labelPositionY', this.vertexDefaults.labelPositionY);
        },
        handleVertexDefaultOpacity: function() {
            this.setVertexDefaultDisplayProperty('opacity', this.vertexDefaults.opacity);
        },
        handleVertexDefaultShape: function() {
            this.setVertexDefaultDisplayProperty('shape', this.vertexDefaults.shape);
        },
        handleVertexDefaultColor: function() {
            this.setVertexDefaultDisplayProperty('color', this.vertexDefaults.color);
        },
        handleVertexDefaultStrokeColor: function() {
            this.setVertexDefaultDisplayProperty('strokeColor', this.vertexDefaults.strokeColor);
        },
        handleVertexDefaultSize: function() {
            this.setVertexDefaultDisplayProperty('size', this.vertexDefaults.size);
        },
        handleVertexDefaultStrokeSize: function() {
            this.setVertexDefaultDisplayProperty('strokeSize', this.vertexDefaults.strokeSize);
        },
        handleVertexDefaultArea: function() {
            this.setVertexDefaultDisplayProperty('area', this.vertexDefaults.area);
        },
        handleVertexDefaultStrokeArea: function() {
            this.setVertexDefaultDisplayProperty('strokeArea', this.vertexDefaults.strokeArea);
        },
        handleVertexDefaultXAttribute: function() {
            this.setVertexDefaultPositionX(this.vertexDefaults.xAttribute, true, false);
        },
        handleVertexDefaultYAttribute: function() {
            this.setVertexDefaultPositionY(this.vertexDefaults.yAttribute, true, true);
        },
        /* Edge */
        handleEdgeDefaultLabelAttribute: function() {
            this.setEdgeDefaultLabelAttribute(this.edgeDefaults.labelAttribute);
        },
        handleEdgeDefaultLabelSize: function() {
            this.setEdgeDefaultDisplayProperty('labelSize', this.edgeDefaults.labelSize);
        },
        handleEdgeDefaultOpacity: function() {
            this.setEdgeDefaultDisplayProperty('opacity', this.edgeDefaults.opacity);
        },
        handleEdgeDefaultShaft: function() {
            this.setEdgeDefaultDisplayProperty('shaft', this.edgeDefaults.shaft);
        },
        handleEdgeDefaultShape: function() {
            this.setEdgeDefaultDisplayProperty('shape', this.edgeDefaults.shape);
        },
        handleEdgeDefaultBidirectional: function() {
            this.setEdgeDefaultDisplayProperty('bidirectional', this.edgeDefaults.bidirectional);
        },
        handleEdgeDefaultColor: function() {
            this.setEdgeDefaultDisplayProperty('color', this.edgeDefaults.color);
        },
        handleEdgeDefaultSize: function() {
            this.setEdgeDefaultDisplayProperty('size', this.edgeDefaults.size);
        },
        /** END Display Properties - Attribute Handlers **/
        /** ** **/
        /** ** **/
        /** ** **/
        handleAttributeEditVertexSelectedChange: function() {
            this.selectedVerticesChanged();
        },
        handleAttributeEditEdgeSelectedChange: function() {
            this.selectedEdgesChanged();
        },
        handleVerticesUpdateRow: function(e) {
            this.$.nodeRender.refreshAttributes();
            if (e.detail.column != null && e.detail.column.name === this.vertexDefaults.labelAttribute) {
                this.handleVertexDefaultLabelAttribute();
            }
        },
        handleEdgesUpdateRow: function(e) {
            this.$.edgeRender.refreshAttributes();
            if (e.detail.column.name === this.edgeDefaults.labelAttribute) {
                this.handleEdgeDefaultLabelAttribute();
            }
        },
        vertexSelectionColorChanged: function(neo, old) {
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                vertex.renderer.select(this.vertexDefaults.selectionColor);
            }
        },
        selectedVerticesChanged: function(changeRecord) {
            // console.time("selectedVerticesChanged")
            if (this.vertices && this.selectedVertices) {
                if (changeRecord) {
                    changeRecord.indexSplices.forEach(function(s) {
                        s.removed.forEach(function(vertex) {
                            vertex.renderer.deselect();
                            console.log(vertex.id + ' deselect');
                        });
                        for (var i = s.index; i < (s.index + s.addedCount); i++) {
                            var vertex = this.selectedVertices[i];
                            vertex.renderer.select(this.vertexDefaults.selectionColor);
                            console.log(vertex.id + ' select');
                        }
                    }, this);
                } else {
                    //Set all not selected
                    for (var i = 0; i < this.vertices.length; i++) {
                        var vertex = this.vertices[i];
                        vertex.renderer.deselect();
                    }
                    //Set selected ones
                    for (var i = 0; i < this.selectedVertices.length; i++) {
                        var vertex = this.selectedVertices[i];
                        vertex.renderer.select(this.vertexDefaults.selectionColor);
                    }
                }
                this.notifyPath('selectedVertices.length', this.selectedVertices.length);
            }
            // console.timeEnd("selectedVerticesChanged");
        },
        selectedEdgesChanged: function(changeRecord) {
            //            console.log('selectedEdgesChanged');
            if (this.edges && this.selectedEdges) {
                if (changeRecord) {
                    changeRecord.indexSplices.forEach(function(s) {
                        s.removed.forEach(function(edge) {
                            edge.renderer.deselect();
                            console.log(edge.id + ' deselect');
                        });
                        for (var i = s.index; i < (s.index + s.addedCount); i++) {
                            var edge = this.selectedEdges[i];
                            edge.renderer.select(this.edgeDefaults.selectionColor);
                            console.log(edge.id + ' select');
                        }
                    }, this);
                } else {
                    //Set all not selected
                    for (var i = 0; i < this.edges.length; i++) {
                        var edge = this.edges[i];
                        edge.renderer.deselect();
                    }
                    //Set selected ones
                    for (var i = 0; i < this.selectedEdges.length; i++) {
                        var edge = this.selectedEdges[i];
                        edge.renderer.select(this.edgeDefaults.selectionColor);
                    }
                }
            }
        },

        //        handleDataChanged: function (neo, old) {
        ////                for (var i = 0; i < this.vAttr.data.length; i++) {
        ////                    var row = this.vAttr.data[i];
        ////                    this.setVertexCoords(row.id, parseFloat(row.x), parseFloat(row.y));
        ////                }
        //        },
        /** Bar Handlers **/
        computeSelectedMenu: function(selectedMenu, option) {
            return selectedMenu === option;
        },
        handleNetworkEditMenu: function(e) {
            this.$.networkEditPanel.show();
        },
        handleNodesEditMenu: function(e) {
            this.$.nodeAttributeEditPanel.show();
        },
        handleEdgesEditMenu: function(e) {
            this.$.edgeAttributeEditPanel.show();
        },
        handleNodesFilterMenu: function(e) {
            this.$.nodeSelectFilterPanel.show();
        },
        handleEdgesFilterMenu: function(e) {
            this.$.edgeSelectFilterPanel.show();
        },
        handleCellbaseMenu: function(e) {
            this.$.cellbaseXrefImportPanel.show();
        },
        handleDrugsMenu: function(e) {
            this.$.drugsPanel.show();
        },
        handleDiseasesMenu: function(e) {
            this.$.diseasesPanel.show();
        },
        handleFunctionalitiesMenu: function() {
            this.$.functionalitiesPanel.show();
        },
        handleSessionStartMenu: function(e) {
            var me = this;
            new StvDialog().confirm('All changes will be lost. Are you sure?', function(res) {
                if (res) {
                    me.startOver();
                }
            });
        },
        handleSessionOpenMenu: function(e) {
            var me = this;
            var file = e.detail.file;
            if (file) {
                var reader = new FileReader();
                reader.onload = function(evt) {
                    try {
                        var jsonStr = pako.ungzip(evt.target.result, {
                            to: 'string'
                        });
                        me.loadJSON(JSON.parse(jsonStr));
                    } catch (err) {
                        console.log('Unable to ungzip');

                        /** **/
                        var stringReader = new FileReader();
                        stringReader.onload = function(evt2) {
                            console.log('Readed as plain text');
                            var jsonStr = evt2.target.result;
                            me.loadJSON(JSON.parse(jsonStr));
                        }
                        stringReader.readAsText(file);
                        /** **/
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        },
        handleSessionSaveMenu: function(e) {
            var isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
            if (isSafari) {
                var content = JSON.stringify(this);
                var blob = new Blob([content], {
                    type: "text/plain;charset=utf-8"
                });
                var initialFileName = 'network.json';

            } else {
                var content = pako.gzip(JSON.stringify(this));
                var blob = new Blob([content], {
                    type: "application/gzip"
                });
                var initialFileName = 'network.json.gz';
            }
            new StvDialog({
                defaultText: initialFileName,
                titleText: 'Download session'
            }).prompt('Please enter file name:', function(res, text) {
                if (res) {
                    var fileName = text;
                    if (fileName != "") {
                        saveAs(blob, fileName);
                    }
                }
            });

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "network.json.gz";
            //            var fileName = window.prompt("Please enter file name", "network.json.gz");
            //            if (fileName != null && fileName != "") {
            //                link.download = fileName;
            //                var event = new MouseEvent('click', {
            //                    'view': window,
            //                    'bubbles': true,
            //                    'cancelable': true
            //                });
            //                link.dispatchEvent(event);
            //            }
        },
        handleSessionManageMenu: function(e) {
            this.$.sessionManagerPanel.show();
        },
        handleImportSifMenu: function(e) {
            this.set('selectedMenu', 'import-sif');
        },
        handleImportTextMenu: function(e) {
            this.selectedMenu = 'import-text';
        },
        handleImportXlsxMenu: function(e) {
            this.selectedMenu = 'import-xlsx';
        },
        handleImportNodeAttrMenu: function(e) {
            this.selectedMenu = 'import-node-attributes';
        },
        handleImportEdgeAttrMenu: function(e) {
            this.selectedMenu = 'import-edge-attributes';
        },
        handleExportSifMenu: function(e) {
            var content = this.exportGraph();
            var blob = new Blob([content], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, "network.sif");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.target = '_blank';
            //            link.href = url;
            //            link.download = "network.sif";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportNodeAttrMenu: function(e) {
            var content = this.exportVertexAttributes();
            var blob = new Blob([content], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, "node.attr");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "node.attr";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportEdgeAttrMenu: function(e) {
            var content = this.exportEdgeAttributes();
            var blob = new Blob([content], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, "edge.attr");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "edge.attr";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportSvgMenu: function(e) {
            var text = this.exportSVG();
            var blob = new Blob([text], {
                type: "image/svg+xml"
            });
            saveAs(blob, "network.svg");
        },
        exportSVG: function() {
            return this.$.networkLayout.exportSVG();
        },
        handleExportPngMenu: function(e) {
            //            Deprecated
        },
        handleNodeSimpleRenderingMenu: function(e) {
            this.$.nodeRenderPanel.show();
        },
        handleEdgeSimpleRenderingMenu: function(e) {
            this.$.edgeRenderPanel.show();
        },
        handleReactomeMenu: function(e) {
            this.$.reactomeImportPanel.show();
        },
        handleKeggMenu: function(e) {
            this.$.keggImportPanel.show();
        },
        handleIntactMenu: function(e) {
            this.$.intactImportPanel.show();
        },
        handleCommunitiesMenu: function(e) {
            this.$.communitiesStructureDetectionPanel.show();
        },
        handleTopologicalMenu: function(e) {
            this.$.topologicalStudyPanel.show();
        },
        /**/
        handleImportSif: function(e) {
            //                _this.configuration.cleanVisualSets();
            this.setGraph(e.detail.graph);
            this.set('lastLoadedFileName', e.detail.fileName);
            this.setLayout('Force directed');

            this.saveLocalStorage();
        },
        handleImportText: function(e) {
            //                _this.configuration.cleanVisualSets();
            this.setGraph(e.detail.graph);
            this.lastLoadedFileName = e.detail.fileName;
            this.setLayout('Force directed');
            this.saveLocalStorage();
        },
        handleImportXlsx: function(e) {
            //                _this.configuration.cleanVisualSets();
            this.setGraph(e.detail.graph);
            this.lastLoadedFileName = e.detail.fileName;
            //                this.$.networkViewer.setLayout(e.detail.layout);
            this.setLayout('Force directed');
            this.saveLocalStorage();
        },
        handleImportNodeAttr: function(e) {
            this.importVertexAttributeManager(e.detail.columns, e.detail.attributes);
        },
        handleImportEdgeAttr: function(e) {
            this.importEdgeAttributeManager(e.detail.columns, e.detail.attributes);
        },
        /** NETWORK **/
        /*SELECT*/
        handleSelectMenu: function(e) {
            switch (e.detail.value) {
                case 'nodes-select-all':
                    this.selectAllVertices();
                    break;
                case 'edges-select-all':
                    this.selectAllEdges();
                    break;
                case 'network-select-all':
                    this.selectAll();
                    break;
                case 'nodes-select-first-neighbourhood':
                    this.selectVerticesNeighbour();
                    break;
                case 'nodes-select-invert':
                    this.selectVerticesInvert();
                    break;
                case 'edges-select-adjacent':
                    this.selectEdgesNeighbour();
                    break;
                default:
                    console.log(e.detail.value + " not defined");
            }
        },
        /*LAYOUT*/
        handleLayoutMenu: function(e) {
            switch (e.detail.value) {
                case 'layout-force-directed':
                    this.setLayout('Force directed');
                    break;
                case 'layout-configure-force-directed':
                    this.$.configureForceDirectedPanel.show();
                    break;
                case 'layout-tree':
                    this.setLayout('Tree');
                    break;
                case 'layout-circle':
                    this.setLayout('Circle', {
                        attributeName: e.detail.subvalue
                    });
                    break;
                case 'layout-random':
                    this.setLayout('Random');
                    break;
                case 'layout-grid':
                    this.setLayout('Grid');
                    break;
                case 'layout-concentric':
                    this.setLayout('Concentric');
                    break;
                case 'layout-configure-concentric':
                    this.$.configureConcentricPanel.show();
                    break;
                case 'layout-breadthfirst':
                    this.setLayout('Breadthfirst');
                    break;
                case 'layout-cose':
                    this.setLayout('Cose');
                    break;
                case 'layout-configure-cose':
                    this.$.configureCosePanel.show();
                    break;
                default:
                    console.log(e.detail.value + " not defined");
            }
        },
        /* toolbar Handlers*/
        handleResetZoom: function() {
            this.resetZoom();
        },
        handleCenterNetwork: function() {
            this.centerNetwork();
        },

        handleLayoutChange: function(e) {
            this.setLayout(e.detail.layout);
        },
        handleSelectChange: function(e) {
            this.select(e.detail.select);
        },
        handleRotateChange: function(e) {
            if ('angle' in e.detail) {
                this.rotateNetwork(e.detail.angle);
            }
            if ('flip' in e.detail) {
                this.flipNetwork(e.detail.flip);
            }
        },
        /* editionbar Handlers*/
        handleVertexEditionBar: function(e) {
            var dp = e.detail.displayProperty;
            var v = e.detail.value;
            if (!isNaN(v)) {
                v = parseFloat(v);
            }
            var updateEdges = false;
            if (dp == 'shape' || dp == 'size' || dp == 'strokeSize') {
                updateEdges = true;
            }
            this.setSelectedVerticesDisplayAttr(dp, v, updateEdges);
        },
        handleVertexSearch: function(e) {
            var str = e.detail.columnName;
            if (e.detail.columnName === 'all') {
                str += ' attributes';
                var selected = [];
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    var vertex = this.graph.vertices[i];
                    for (var att in vertex.attributes) {
                        if (vertex.attributes[att].toString().indexOf(e.detail.value) != -1) {
                            selected.push(vertex);
                            break;
                        }
                    }
                }
                this.set('selectedVertices', selected);
            } else {
                str += ' attribute';
                this.selectVerticesByAttribute(e.detail.columnName, e.detail.value);
            }
            if (this.selectedVertices.length == 0) {
                stv.utils.msg('Search results', 'Your search using ' + str + ' "' + e.detail.value + '" using did not match any node.');
            } else {
                stv.utils.msg('Search results', this.selectedVertices.length + ' nodes found using ' + str + '. The found nodes has been selected.');
            }
        },
        handleVertexNameField: function(e) {
            this.setVertexLabel(e.detail.value);
        },
        handleEdgeEditionBar: function(e) {
            var dp = e.detail.displayProperty;
            var v = e.detail.value;
            if (!isNaN(v)) {
                v = parseFloat(v);
            }
            this.setSelectedEdgesDisplayAttr(dp, v);
        },
        handleEdgeSearch: function(e) {
            this.selectEdgesByAttribute(e.detail.columnName, e.detail.value);
        },
        handleEdgeNameField: function(e) {
            this.setEdgeLabel(e.detail.value);
        },
        /** Layout Handlers **/
        handleCreateVertex: function(e) {
            e.stopPropagation();
            var v = this.createVertex(e.detail.x, e.detail.y);
            this.addActionStack();
            this.fire('createvertex', {
                vertex: v
            });
        },
        handleSelectVertex: function(e) {
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.selectVertex(vertex, e.detail.addToSelection);
        },
        handleSelectEdge: function(e) {
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.selectEdge(edge, e.detail.addToSelection);
        },
        handleMoveSelectedVertices: function(e) {
            this.moveSelectedVertices(e.detail.dispX, e.detail.dispY);
            this.$.nodeTooltip.hideMenu();
        },
        handleSelectArea: function(e) {
            this.selectByArea(e.detail.x, e.detail.y, e.detail.width, e.detail.height);
        },
        handleCreateEdge: function(e) {
            e.stopPropagation();
            var source = this.graph.getVertexById(e.detail.sourceId);
            var target = this.graph.getVertexById(e.detail.targetId);
            var e = this.createEdge(source, target);
            this.addActionStack();
            this.fire('createedge', {
                edge: e
            });
        },
        handleRemoveVertex: function(e) {
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.removeVertex(vertex);
            this.addActionStack();
        },
        handleRemoveEdge: function(e) {
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.removeEdge(edge);
            this.addActionStack();
        },
        handleLeftClickVertex: function(e) {
            e.stopPropagation();

            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.$.editionBar.vertexColor = vertex.renderer.color;
            this.$.editionBar.vertexStrokeColor = vertex.renderer.strokeColor;
            //    this.$.editionBar.vertexNameField = vertex.renderer.labelText;
            this.$.editionBar.vertexSizeField = vertex.renderer.size;
            this.$.editionBar.vertexStrokeSizeField = vertex.renderer.strokeSize;
            this.$.editionBar.selectedBar = 'vertex';

            var bcr = this.getBoundingClientRect();
            this.fire('leftclickvertex', {
                x: e.detail.x + bcr.left + 15,
                y: e.detail.y + bcr.top + 15,
                vertex: vertex,
                nv: this
            });
        },
        handleLeftClickEdge: function(e) {
            e.stopPropagation();

            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.$.editionBar.edgeColor = edge.renderer.color;
            this.$.editionBar.edgeSizeField = edge.renderer.size;
            //                this.$.editionBar.edgeNameField = edge.renderer.labelText;
            this.$.editionBar.selectedBar = 'edge';

            var bcr = this.getBoundingClientRect();
            this.fire('leftclickedge', {
                x: e.detail.x + bcr.left + 15,
                y: e.detail.y + bcr.top + 15,
                edge: edge,
                nv: this
            });
        },

        /** Context Handlers **/
        _hideVertexContextMenu: function() {
            this.$.vertexcontextmenu.setAttribute('hidden', '');
            this.$.vertexcontextmenu.style.opacity = "";
            this.$.vertexcontextmenu.style.visibility = "";
            this._lastContextVertexAttributes = [];
        },
        _hideEdgeContextMenu: function() {
            this.$.edgecontextmenu.setAttribute('hidden', '');
            this.$.edgecontextmenu.style.opacity = "";
            this.$.edgecontextmenu.style.visibility = "";
            this._lastContextEdgeAttributes = [];
        },
        _showVertexContextMenu: function(x, y) {
            this.$.vertexcontextmenu.removeAttribute('hidden');
            var bcrnl = this.$.networkLayout.getBoundingClientRect();
            this.$.vertexcontextmenu.style.opacity = "1";
            this.$.vertexcontextmenu.style.visibility = "visible";
            this.$.vertexcontextmenu.style.top = (bcrnl.top + y + 10) + "px";
            this.$.vertexcontextmenu.style.left = (bcrnl.left + x + 10) + "px";
        },
        _showEdgeContextMenu: function(x, y) {
            this.$.edgecontextmenu.removeAttribute('hidden');
            var bcrnl = this.$.networkLayout.getBoundingClientRect();
            this.$.edgecontextmenu.style.opacity = "1";
            this.$.edgecontextmenu.style.visibility = "visible";
            this.$.edgecontextmenu.style.top = (bcrnl.top + y + 10) + "px";
            this.$.edgecontextmenu.style.left = (bcrnl.left + x + 10) + "px";
        },
        handleRightClickVertex: function(e) {
            e.stopPropagation();
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.lastContextVertex = vertex;
            this._lastContextVertexAttributes = [];
            if (this.disableContextMenu === false) {
                this._hideEdgeContextMenu();
                this._showVertexContextMenu(e.detail.x, e.detail.y);
                var attrs = [];
                for (var key in vertex.attributes) {
                    attrs.push({
                        key: key,
                        value: vertex.attributes[key]
                    });
                }
                this._lastContextVertexAttributes = attrs;
            }
            var bcr = this.getBoundingClientRect();
            this.fire('rightclickvertex', {
                x: e.detail.x + bcr.left + 15,
                y: e.detail.y + bcr.top + 15,
                vertex: vertex,
                e: e.detail.e,
                nv: this
            });
        },
        handleRightClickEdge: function(e) {
            e.stopPropagation();
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.lastContextEdge = edge;
            this._lastContextEdgeAttributes = [];
            if (this.disableContextMenu === false) {
                this._hideVertexContextMenu();
                this._showEdgeContextMenu(e.detail.x, e.detail.y);
                var attrs = [];
                for (var key in edge.attributes) {
                    attrs.push({
                        key: key,
                        value: edge.attributes[key]
                    });
                }
                this._lastContextEdgeAttributes = attrs;
            }
            var bcr = this.getBoundingClientRect();
            this.fire('rightclickedge', {
                x: e.detail.x + bcr.left + 15,
                y: e.detail.y + bcr.top + 15,
                edge: edge,
                e: e.detail.e,
                nv: this
            });
        },
        handleHoverVertex: function(e) {
            var me = this;
            e.stopPropagation();
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            var nlbcr = this.$.networkLayout.getBoundingClientRect();

            var coX = function(x) {
                return (x + (me.center.x / me.scale)) * me.scale;
            }
            var coY = function(y) {
                return (y + (me.center.y / me.scale)) * me.scale;
            }
            var w2, h2;
            if (vertex.renderer.size < 0) {
                var vbcr = vertex.renderer.groupEl.getBoundingClientRect();
                w2 = (vbcr.width / 2);
                h2 = (vbcr.height / 2);
            } else {
                s2 = vertex.renderer.getSize() / 2;
                w2 = s2 * me.scale;
                h2 = s2 * me.scale;
            }
            var tipX = coX(vertex.position.x) + w2 + nlbcr.left;
            var tipY = coY(vertex.position.y) + h2 + nlbcr.top;
            this.fire('hoververtex', {
                x: e.detail.x + nlbcr.left + 15,
                y: e.detail.y + nlbcr.top + 15,
                tipX: tipX,
                tipY: tipY,
                vertex: vertex,
                e: e.detail.e,
                nv: this
            });

            if (this.disableTooltip != true) {
                if (this.$.nodeTooltip.isMenuHidden()) {
                    this.lastHoverVertex = null;
                }
                if (this.lastHoverVertex != vertex) {
                    this.$.nodeTooltip.hideMenu();
                    this.lastHoverVertex = vertex;
                    this.debounce('showMenu', function() {
                        if (vertex != null && vertex.attributes.tooltip != null && vertex.attributes.tooltip.toString().trim() != "") {
                            var html = vertex.attributes.tooltip.replace(/\\n/, '<br>');
                            Polymer.dom(this.$.nodeTooltipContent).innerHTML = html;
                            this.$.nodeTooltip.showMenu(tipX, tipY);
                        }
                    }, 600)
                }
            }

        },
        handleHoverEdge: function(e) {
            e.stopPropagation();
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            var bcr = this.getBoundingClientRect();
            this.fire('hoveredge', {
                x: e.detail.x + bcr.left + 15,
                y: e.detail.y + bcr.top + 15,
                edge: edge,
                e: e.detail.e,
                nv: this
            });
        },
        handleContextRemoveVertex: function(e) {
            var me = this;
            new StvDialog().confirm('Remove selected vertex?', function(res) {
                if (res) {
                    me._hideVertexContextMenu();
                    me.removeVertex(me.lastContextVertex);
                    me.addActionStack();
                }
            });
        },
        handleContextRemoveEdge: function(e) {
            var me = this;
            new StvDialog().confirm('Remove selected edge?', function(res) {
                if (res) {
                    me._hideEdgeContextMenu();
                    me.removeEdge(me.lastContextEdge);
                    me.addActionStack();
                }
            });
        },
        handleContextRemoveSelectedVertices: function(e) {
            var me = this;
            new StvDialog().confirm('Remove selected vertices?', function(res) {
                if (res) {
                    me._hideVertexContextMenu();
                    me.removeSelectedVertices();
                    me.addActionStack();
                }
            });
        },
        handleContextRemoveSelectedEdges: function(e) {
            var me = this;
            new StvDialog().confirm('Remove selected edges?', function(res) {
                if (res) {
                    me._hideVertexContextMenu();
                    me.removeSelectedEdges();
                    me.addActionStack();
                }
            });
        },
        handleContextSelectVerticesNeighbour: function(e) {
            this.selectVertex(this.lastContextVertex);
            this.selectVerticesNeighbour();
        },
        handleContextSelectEdgesNeighbour: function(e) {
            this.selectVertex(this.lastContextVertex);
            this.selectEdgesNeighbour();
        },
        _hideImageContextMenu: function() {
            this.$.imagecontextmenu.setAttribute('hidden', '');
            this.$.imagecontextmenu.style.opacity = "";
            this.$.imagecontextmenu.style.visibility = "";
        },
        handleRightClickBackgroundImage: function(e) {
            if (this.disableContextMenu === true) {
                return;
            }
            this.$.imagecontextmenu.removeAttribute('hidden');
            //                var bcr = e.detail.targetEl.getBoundingClientRect()
            var bcrnl = this.$.networkLayout.getBoundingClientRect();
            //                console.log(bcr)
            //                console.log(bcrnl.top)
            //                console.log(e.detail)
            //                console.log(e.detail.targetEl)
            //                console.log(this.$.networkLayout.targetEl)
            this.$.imagecontextmenu.style.opacity = "1";
            this.$.imagecontextmenu.style.visibility = "visible";
            this.$.imagecontextmenu.style.top = (bcrnl.top + e.detail.y) + "px";
            this.$.imagecontextmenu.style.left = (bcrnl.left + e.detail.x) + "px";
            this._lastImageElClicked = e.detail.targetEl;
        },
        handleContextRemoveBackGroundImage: function(e) {
            this._hideImageContextMenu();
            this.removeBackGroundImage(this._lastImageElClicked);
            this.addActionStack();
        },

        /** network edit **/
        handleNetworkEditAddVertex: function(e) {
            var vertex = this.createVertex(null, null, e.detail.id);
        },
        handleNetworkEditAddEdge: function(e) {
            var sourceVertex = this.createVertex(null, null, e.detail.source);
            var targetVertex = this.createVertex(null, null, e.detail.target);
            var edge = this.createEdge(sourceVertex, targetVertex, e.detail.relation);
        },
        /** Cellbase import **/
        handleCellbaseAddColumns: function(e) {
            this._addColumns(e.detail, 'vertexColumns');
        },
        /** IntAct import**/
        handleIntactGraph: function(e) {
            this.setGraph(e.detail.graph);
            this.setLayout('Force directed');
        },
        handleReactomeGraph: function(e) {
            this.startOver();
            this.setGraph(e.detail.graph);
            var cols = [{
                name: "x",
                title: "x",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }, {
                name: "y",
                title: "y",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }];
            var map = e.detail.map;
            for (var i = 0; i < this.vertices.length; i++) {
                var attributes = this.vertices[i].attributes;
                attributes["name"] = map[attributes["id"]].name;
                attributes["x"] = map[attributes["id"]].x;
                attributes["y"] = map[attributes["id"]].y;
            }
            this._addColumns(cols, 'vertexColumns');

            this.vertexDefaults.labelAttribute = "name";
            this.handleVertexDefaultLabelAttribute();

            this.handleVertexDefaultXAttribute();
            this.handleVertexDefaultYAttribute();
            this.setLayout("Force directed");
        },
        handleKeggGraph: function(e) {
            this.startOver();
            this.setGraph(e.detail.graph);
            var vertexCols = [{
                name: "x",
                title: "x",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }, {
                name: "y",
                title: "y",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }, {
                name: "entryName",
                title: "Entry name",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }];
            var edgeCols = [{
                name: "type",
                title: "Type",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }];
            var map = e.detail.map;
            for (var i = 0; i < this.vertices.length; i++) {
                var attributes = this.vertices[i].attributes;
                attributes["name"] = map[attributes["id"]].name;
                attributes["entryName"] = map[attributes["id"]].entryName;
                attributes["x"] = map[attributes["id"]].x;
                attributes["y"] = map[attributes["id"]].y;
            }
            this._addColumns(vertexCols, 'vertexColumns');
            this._addColumns(edgeCols, 'edgeColumns');

            this.vertexDefaults.labelAttribute = "name";
            this.handleVertexDefaultLabelAttribute();

            this.handleVertexDefaultXAttribute();
            this.handleVertexDefaultYAttribute();
            //            me.setLayout("Force directed");

            var matches = {};
            for (var i = 0; i < this.edges.length; i++) {
                var edge = this.edges[i];
                if (edge.attributes.relation === 'inhibition' || edge.attributes.relation === 'repression') {
                    matches[edge.attributes.relation] = 'inhibited';
                } else if (edge.attributes.relation === 'binding/association') {
                    matches[edge.attributes.relation] = 'undirected';
                } else {
                    matches[edge.attributes.relation] = 'directed';
                }
            }
            // for (var i = 0; i < this.edges.length; i++) {
            //     var edge = this.edges[i];
            //     if (edge.attributes.relation === 'inhibition' || edge.attributes.relation === 'repression') {
            //         matches[edge.attributes.relation] = 'red';
            //     } else if (edge.attributes.relation === 'binding/association') {
            //         matches[edge.attributes.relation] = 'blue';
            //     } else {
            //         matches[edge.attributes.relation] = 'orange';
            //     }
            // }
            this.$.edgeRender.applyVisualSet({
                attribute: "relation",
                displayProperty: "shape",
                enabled: true,
                matches: matches,
                parse: "string",
                type: "categorical"
            });
            // this.$.edgeRender.applyVisualSet({
            //     attribute: "relation",
            //     displayProperty: "color",
            //     enabled: true,
            //     matches: matches,
            //     parse: "string",
            //     type: "categorical"
            // });
        },
        handleCommunityAttributes: function(e) {
            var attr = e.detail.attributes;
            for (var i = 0; i < attr.length; i++) {
                var obj = attr[i];
                var vertex = this.graph.getVertexById(obj.id);
                var attributes = vertex.attributes;
                attributes["community"] = obj.community;
                attributes["communityColor"] = obj.communityColor;
            }
            this._addColumns(e.detail.columns, 'vertexColumns');
        },
        handleApplyCommunity: function(e) {
            this.vertexDefaults.labelAttribute = "name";
            this.handleVertexDefaultLabelAttribute();

            var nodeRender = this.$.nodeRender;
            nodeRender.applyDirect('communityColor', 'color');
        },
        handleTopologicalAttributes: function(e) {
            var attr = e.detail.attributes;
            for (var i = 0; i < attr.length; i++) {
                var obj = attr[i];
                var vertex = this.graph.getVertexById(obj.id);
                if (vertex != null) {
                    var attributes = vertex.attributes;
                    attributes["degree"] = obj.degree;
                    attributes["betweenness"] = obj.betweenness;
                    attributes["closeness"] = obj.closeness;
                    attributes["clusteringCoefficient"] = obj.clusteringCoefficient;
                }
            }
            this._addColumns(e.detail.columns, 'vertexColumns');
        },
        handleApplyDrugsColor: function(e) {
            var nodeRender = this.$.nodeRender;
            var matches = {};
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                if (vertex.attributes.drugs === 'none') {
                    matches[vertex.attributes.drugs] = '#FFFFFF';
                } else {
                    matches[vertex.attributes.drugs] = '#FF0000';
                }
            }
            nodeRender.applyVisualSet({
                attribute: "drugs",
                displayProperty: "color",
                enabled: true,
                matches: matches,
                parse: "string",
                type: "categorical"
            });
        },
        handleApplyDrugsMulticolor: function(e) {
            var nodeRender = this.$.nodeRender;
            var matches = {};
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                var drugs = vertex.attributes.drugs.split(',');
                for (var j = 0; j < drugs.length; j++) {
                    var drug = drugs[j];
                    if (drug === 'none') {
                        matches[drug] = '#FFFFFF';
                    } else {
                        matches[drug] = Utils.randomColor();
                    }
                }
            }
            nodeRender.applyVisualSet({
                attribute: "drugs",
                displayProperty: "color",
                enabled: true,
                matches: matches,
                parse: "list",
                type: "categorical"
            });
        },
        handleApplyDiseasesMulticolor: function(e) {
            var nodeRender = this.$.nodeRender;
            var matches = {};
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                var diseases = vertex.attributes.diseases.split(',');
                for (var j = 0; j < diseases.length; j++) {
                    var disease = diseases[j];
                    if (diseases === 'none') {
                        matches[disease] = '#FFFFFF';
                    } else {
                        matches[disease] = Utils.randomColor();
                    }
                }
            }
            nodeRender.applyVisualSet({
                attribute: "diseases",
                displayProperty: "color",
                enabled: true,
                matches: matches,
                parse: "list",
                type: "categorical"
            });
        },
        /**
         /** Methods
         /***********/
        selectAll: function() {
            this.selectAllVertices();
            this.selectAllEdges();
        },
        selectVertex: function(vertex, addToSelection) {
            if (!vertex.renderer.selected) {
                if (addToSelection) {
                    this.push('selectedVertices', vertex);
                } else {
                    this.set('selectedVertices', [vertex]);
                }
            } else {
                if (addToSelection) {
                    this.arrayDelete('selectedVertices', vertex);
                }
            }
        },
        selectAllVertices: function() {
            this.set('selectedVertices', this.graph.vertices.slice());
        },
        deselectAllVertices: function() {
            this.set('selectedVertices', []);
        },
        selectEdge: function(edge, addToSelection) {
            if (!edge.renderer.selected) {
                if (addToSelection) {
                    this.push('selectedEdges', edge);
                } else {
                    this.set('selectedEdges', [edge]);
                }
            } else if (addToSelection) {
                this.arrayDelete('selectedEdges', edge);
            }
        },
        selectAllEdges: function() {
            this.set('selectedEdges', this.graph.edges.slice());
        },
        deselectAllEdges: function() {
            this.set('selectedEdges', []);
        },
        selectVerticesNeighbour: function() {
            var selectedVertices = [];
            var selectedVerticesMap = {};
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                selectedVertices.push(vertex);
                selectedVerticesMap[vertex.id] = vertex;
                for (var j = 0; j < vertex.edges.length; j++) {
                    var edge = vertex.edges[j];
                    if (!selectedVerticesMap[edge.source.id]) {
                        selectedVertices.push(edge.source);
                        selectedVerticesMap[edge.source.id] = edge.source;
                    }
                    if (!selectedVerticesMap[edge.target.id]) {
                        selectedVertices.push(edge.target);
                        selectedVerticesMap[edge.target.id] = edge.target;
                    }
                }
            }
            this.set('selectedVertices', selectedVertices);
        },
        selectEdgesNeighbour: function() {
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                for (var j = 0; j < vertex.edges.length; j++) {
                    var edge = vertex.edges[j];
                    if (!edge.renderer.selected) {
                        this.selectEdge(edge, true);
                    }
                }
            }
        },
        selectVerticesInvert: function() {
            var selected = [];
            for (var i = 0; i < this.graph.vertices.length; i++) {
                var vertex = this.graph.vertices[i];
                if (!vertex.renderer.selected) {
                    selected.push(vertex);
                }
            }
            this.set('selectedVertices', selected);
        },
        selectEdgesInvert: function() {
            var selected = [];
            for (var i = 0; i < this.graph.edges.length; i++) {
                var edge = this.graph.edges[i];
                if (!edge.renderer.selected) {
                    selected.push(edge.id);
                }
            }
            this.set('selectedEdges', selected);
        },
        selectByArea: function(x, y, width, height) {
            this.deselectAllVertices();
            this.deselectAllEdges();
            if (width > 0 && height > 0) {
                x -= this.center.x;
                y -= this.center.y;
                x /= this.scale;
                y /= this.scale;
                width /= this.scale;
                height /= this.scale;
                var vSelected = [];
                var eSelected = [];
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    var vertex = this.graph.vertices[i];
                    if (vertex.position.x >= x && vertex.position.x <= x + width && vertex.position.y >= y && vertex.position.y <= y + height) {
                        vSelected.push(vertex);
                        for (var j = 0; j < vertex.edges.length; j++) {
                            var edge = vertex.edges[j];
                            eSelected.push(edge);
                        }
                    }
                }
                this.set('selectedVertices', vSelected);
                this.set('selectedEdges', eSelected);
            }
        },
        _updateEdgeCoords: function(vertex) {
            for (var i = 0; i < vertex.edges.length; i++) {
                var edge = vertex.edges[i];
                if (vertex === edge.source) {
                    edge.renderer.move();
                }
                if (vertex === edge.target) {
                    edge.renderer.move();
                }
            }
            this.debounce('click', function() {
                this.addActionStack();
            }, 600);
        },
        moveSelectedVertices: function(dispX, dispY) {
            dispX /= this.scale;
            dispY /= this.scale;
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                vertex.position.x += dispX;
                vertex.position.y += dispY;
                vertex.renderer.move();
                this._updateEdgeCoords(vertex);
            }
            this.$.nodeAttributeEdit.update();
        },
        selectVerticesByIds: function(vertexIds) {
            var selected = [];
            for (var i = 0; i < vertexIds.length; i++) {
                var id = vertexIds[i];
                var vertex = this.graph.getVertexById(id);
                if (vertex != null) {
                    selected.push(vertex);
                }
            }
            this.set('selectedVertices', selected);
        },
        selectVerticesByAttribute: function(attributeName, attributeValue) {
            var selected = [];
            for (var i = 0; i < this.graph.vertices.length; i++) {
                var vertex = this.graph.vertices[i];
                if (vertex.attributes[attributeName] === attributeValue) {
                    selected.push(vertex);
                }
            }
            this.set('selectedVertices', selected);
        },
        centerVertex: function(vertex) {
            //                var clientRect = this.$.networkLayout.getBoundingClientRect();
            //                var centerX = clientRect.width / 2;
            //                var centerY = clientRect.height / 2;
            //                this.tx = this.x + (-centerX * (this.scale - 1));
            //                this.ty = this.y + (-centerY * (this.scale - 1));
            //
            //                var dx = centerX - vertex.position.x
            //                var dy = centerY - vertex.position.y;
            //                this.center.x = dx;
            //                this.center.y = dy;
            vertex.position.x = this.center.x;
            vertex.position.y = this.center.y;
            vertex.renderer.move();
        },
        selectEdgesByAttribute: function(attributeName, attributeValue) {
            var selected = [];
            for (var i = 0; i < this.graph.edges.length; i++) {
                var edge = this.graph.edges[i];
                if (edge.attributes[attributeName] === attributeValue) {
                    selected.push(edge);
                }
            }
            this.set('selectedEdges', selected);
        },
        setVertexCoords: function(vertexId, x, y) {
            var vertex = this.graph.getVertexById(vertexId);
            if (x != null) {
                vertex.position.x = x;
            }
            if (y != null) {
                vertex.position.y = y;
            }
            vertex.renderer.move();
            this._updateEdgeCoords(vertex);
        },
        removeVertex: function(vertex) {
            this._removeVertex(vertex);
            this.deselectAllVertices();
        },
        _removeVertex: function(vertex) {
            for (var i = 0; i < vertex.edges.length; i++) {
                var edge = vertex.edges[i];
                edge.renderer.remove();
            }
            vertex.renderer.remove();
            this.graph.removeVertex(vertex);
        },
        removeEdge: function(edge) {
            edge.renderer.remove();
            this.graph.removeEdge(edge);
            this.deselectAllEdges();
        },
        removeSelectedVertices: function() {
            this.graph.removeVertices(this.selectedVertices);
            this.deselectAllVertices();
            this.refreshGraphView(this.graph, true);
        },
        removeSelectedEdges: function() {
            var edgesToDelete = [];
            var edgeMap = {};
            for (var i = 0; i < this.selectedEdges.length; i++) {
                var edge = this.selectedEdges[i];
                if (edgeMap[edge.id] != true) {
                    edgeMap[edge.id] = true;
                    edgesToDelete.push(edge);
                    edge.renderer.remove();
                }
            }
            this.graph.removeEdges(edgesToDelete);
        },
        setSelectedVerticesDisplayAttr: function(displayProperty, value, updateEdges) {
            var vertex;
            for (var i = 0, li = this.selectedVertices.length; i < li; i++) {
                vertex = this.selectedVertices[i];
                vertex.renderer.set(displayProperty, value);
                if (updateEdges) {
                    this._updateEdgeCoords(vertex);
                }
            }
        },
        setSelectedEdgesDisplayAttr: function(displayProperty, value) {
            var edge;
            for (var i = 0, li = this.selectedEdges.length; i < li; i++) {
                edge = this.selectedEdges[i];
                edge.renderer.set(displayProperty, value);
            }
        },
        setVertexLabel: function(label) {
            //TODO
            //                if (this.selectedVertices.length == 1) {
            //                    var vertex = this.selectedVertices[0];
            //                    this.network.setVertexLabel(vertex, label);
            //                }
        },
        setEdgeLabel: function(label) {
            //TODO
            //                if (this.selectedEdges.length == 1) {
            //                    var edge = this.selectedEdges[0];
            //                    this.network.setEdgeLabel(edge, label);
            //                }
        },
        createVertex: function(x, y, id) {
            if (x == null) {
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                x = clientRect.width / 2;
            } else {
                x -= this.center.x;
                x /= this.scale;
            }
            if (y == null) {
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                y = clientRect.height / 2;
            } else {
                y -= this.center.y;
                y /= this.scale;
            }
            if (id == null) {
                id = this.graph.getNextVertexId();
                // id = 'n' + Math.floor(Math.random() * (999999 - 100000 + 1));
            }
            /* vertex graph */
            var vertex = new Vertex({
                id: id,
                position: new Point(x, y),
                renderer: new CircosVertexRenderer(this.vertexDefaults)
            });
            vertex.attributes.id = vertex.id;
            vertex.attributes.name = vertex.id;
            var added = this.graph.addVertex(vertex);
            if (added) {
                vertex.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            } else {
                vertex = this.graph.getVertexById(id);
            }
            var label = vertex.attributes[this.vertexDefaults.labelAttribute];
            vertex.renderer.setLabelContent(label);
            return vertex;
        },
        createVertices: function(idList) {
            for (var i = 0; i < idList.length; i++) {
                var id = idList[i];
                this.createVertex(0, 0, id);
            }
        },
        createEdge: function(vertexSource, vertexTarget, relation) {
            if (relation == null) {
                // relation = 'e' + Math.floor(Math.random() * (999999 - 100000 + 1));
                relation = this.graph.getNextEdgeRelation();
            }
            var id = vertexSource.id + '_' + relation + '_' + vertexTarget.id
            /* edge graph */
            var edge = new Edge({
                id: id,
                relation: relation,
                source: vertexSource,
                target: vertexTarget,
                renderer: new DefaultEdgeRenderer(this.edgeDefaults)
            });
            edge.attributes.id = edge.id;
            edge.attributes.name = edge.id;
            edge.attributes.relation = edge.relation;
            var added = this.graph.addEdge(edge);
            if (added) {
                edge.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            } else {
                edge = this.graph.getEdgeById(id);
            }
            return edge;
        },
        swapEdgeDirection: function(edge) {
            if (edge) {
                var s = edge.source;
                var t = edge.target;
                var r = edge.relation;
                var a = edge.attributes;
                this.removeEdge(edge);
                var e = this.createEdge(t, s, r);
                for (var att in a) {
                    e.attributes[att] = a[att]
                }
                this.$.edgeAttributeEdit.update();
            }
        },
        removeBackGroundImage: function(imageEl) {
            if (imageEl && imageEl.parentNode) {
                imageEl.parentNode.removeChild(imageEl);
            }
        },
        rotateNetwork: function(angle) {
            var vertices = this.graph.vertices;
            if (vertices.length > 0) {
                var intPattern = /^-?\d+$/;
                if (angle && intPattern.test(angle)) {

                    // calculate network bounding coords
                    var minX = vertices[0].position.x,
                        minY = vertices[0].position.y,
                        maxX = minX,
                        maxY = minY;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        var vertex = vertices[i];
                        if (vertex.position.x < minX) {
                            minX = vertex.position.x;
                        }
                        if (vertex.position.x > maxX) {
                            maxX = vertex.position.x;
                        }
                        if (vertex.position.y < minY) {
                            minY = vertex.position.y;
                        }
                        if (vertex.position.y > maxY) {
                            maxY = vertex.position.y;
                        }
                    }
                    var centerX = (maxX + minX) / 2;
                    var centerY = (maxY + minY) / 2;

                    var rotationInRadians = angle * Math.PI / 180.0;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        var vertex = vertices[i];
                        var vCoords = vertex.position;
                        //Detect angle and radius using width/2 and height/2 as center
                        var deltaX = vCoords.x - centerX;
                        var deltaY = vCoords.y - centerY;
                        var radius = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                        var delta = deltaY / deltaX;
                        var angleRad = (isNaN(delta)) ? 0 : Math.atan(delta) + rotationInRadians;
                        //Fix Quadrant
                        angleRad = (vCoords.x < centerX) ? angleRad += Math.PI : angleRad;
                        var x = centerX + (radius * Math.cos(angleRad));
                        var y = centerY + (radius * Math.sin(angleRad));
                        //
                        this.setVertexCoords(vertex.id, x, y);
                    }

                    this.addActionStack();
                }
            }
        },
        flipNetwork: function(direction) {
            var vertices = this.graph.vertices;
            if (vertices.length > 0) {
                // calculate network bounding coords
                var minX = vertices[0].position.x,
                    minY = vertices[0].position.y,
                    maxX = minX,
                    maxY = minY;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    var vertex = vertices[i];
                    if (vertex.position.x < minX) {
                        minX = vertex.position.x;
                    }
                    if (vertex.position.x > maxX) {
                        maxX = vertex.position.x;
                    }
                    if (vertex.position.y < minY) {
                        minY = vertex.position.y;
                    }
                    if (vertex.position.y > maxY) {
                        maxY = vertex.position.y;
                    }
                }

                if (direction === 'horizontal') {
                    var x;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        var vertex = vertices[i];
                        x = maxX - vertex.position.x + minX;
                        this.setVertexCoords(vertex.id, x, vertex.position.y);
                    }
                } else if (direction === 'vertical') {
                    var y;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        var vertex = vertices[i];
                        y = maxY - vertex.position.y + minY;
                        this.setVertexCoords(vertex.id, vertex.position.x, y);
                    }
                }
                this.addActionStack();
            }
        },
        getOrderedIdsByAttribute: function(attributeName) {
            var type = 'float';
            var checkType = true;
            var values = [];
            var vertex, value, l = this.graph.vertices.length;
            for (var i = 0; i < l; i++) {
                vertex = this.graph.vertices[i];
                value = vertex.attributes[attributeName];
                if (!value) {
                    value = '';
                }
                /* detect number or string */
                if (checkType) {
                    var parseResult = parseFloat(value);
                    if (isNaN(parseResult)) {
                        var type = 'string';
                        checkType = false;
                    }
                }
                /* - - - - - - - - - - - - */
                values.push({
                    id: vertex.id,
                    value: value
                });
            }
            switch (type) {
                case 'float':
                    values.sort(function(a, b) {
                        return parseFloat(a.value) - parseFloat(b.value);
                    });
                    break;
                    /* string */
                default:
                    values.sort(function(a, b) {
                        return (a.value > b.value) - (a.value < b.value);
                    });
            }
            return values;
        },
        setLayout: function(type, e) {
            if (this.vertices.length > 0) {

                var me = this;
                this.x = 0;
                this.y = 0;
                var graph = this.graph;
                var dot = graph.getAsDOT();
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                var width = (clientRect.width == 0) ? window.innerWidth : clientRect.width;
                var height = (clientRect.height == 0) ? window.innerHeight : clientRect.height;
                switch (type) {
                    case "Circle":
                        if (e && typeof e.attributeName !== 'undefined') {
                            GraphLayout.circle(me, width, height, this.getOrderedIdsByAttribute(e.attributeName));
                        } else {
                            GraphLayout.circle(me, width, height);
                        }
                        me.addActionStack();
                        me.centerNetwork();
                        break;
                    case "Random":
                        GraphLayout.random2d(me, width, height);
                        me.addActionStack();
                        me.centerNetwork();
                        break;
                    case "none":
                        break;
                    case "Force directed":
                        GraphLayout.force({
                            network: me,
                            width: width,
                            height: height,
                            end: function(verticesArray) {
                                for (var i = 0, l = verticesArray.length; i < l; i++) {
                                    var v = verticesArray[i];
                                    me.setVertexCoords(v.id, v.x, v.y);
                                }
                                me.addActionStack();
                                me.centerNetwork();
                            }
                        });
                        break;
                    case "Force directed (simulation)":
                        GraphLayout.force({
                            network: me,
                            width: width,
                            height: height,
                            simulation: true,
                            end: function(verticesArray) {
                                for (var i = 0, l = verticesArray.length; i < l; i++) {
                                    var v = verticesArray[i];
                                    me.setVertexCoords(v.id, v.x, v.y);
                                }
                                me.centerNetwork();
                            }
                        });
                        break;
                    case "Tree":
                        if (this.vAttr.selected.length == 1) {
                            GraphLayout.tree({
                                network: me,
                                width: width,
                                height: height - 100,
                                root: this.graph.getVertexById(this.vAttr.selected[0].id),
                                end: function(verticesArray) {
                                    for (var i = 0, l = verticesArray.length; i < l; i++) {
                                        var v = verticesArray[i];
                                        me.setVertexCoords(v.name, -v.x + (width), v.y + 50);
                                    }
                                    me.centerNetwork();
                                }
                            });
                        } else {
                            new StvDialog().alert('Please select only one vertex to use it as root.');
                        }
                        break;
                    case 'Grid':
                        GraphLayout.grid({
                            network: me,
                            width: width,
                            height: height - 100,
                            end: function(eles) {
                                for (var i = 0, l = eles.length; i < l; i++) {
                                    var e = eles[i];
                                    if (e.group() === 'nodes') {
                                        var position = e.position();
                                        me.setVertexCoords(e.id(), position.x, position.y);
                                    }
                                }
                                me.addActionStack();
                                me.centerNetwork();
                            }
                        });
                        break;
                    case 'Concentric':
                        GraphLayout.concentric({
                            network: me,
                            width: width,
                            height: height - 100,
                            end: function(eles) {
                                for (var i = 0, l = eles.length; i < l; i++) {
                                    var e = eles[i];
                                    if (e.group() === 'nodes') {
                                        var position = e.position();
                                        me.setVertexCoords(e.id(), position.x, position.y);
                                    }
                                }
                                me.addActionStack();
                                me.centerNetwork();
                            }
                        });
                        break;
                    case 'Breadthfirst':
                        GraphLayout.breadthfirst({
                            network: me,
                            width: width,
                            height: height - 100,
                            end: function(eles) {
                                for (var i = 0, l = eles.length; i < l; i++) {
                                    var e = eles[i];
                                    if (e.group() === 'nodes') {
                                        var position = e.position();
                                        me.setVertexCoords(e.id(), position.x, position.y);
                                    }
                                }
                                me.addActionStack();
                                me.centerNetwork();
                            }
                        });
                        break;
                    case 'Cose':
                        GraphLayout.cose({
                            network: me,
                            width: width,
                            height: height - 100,
                            end: function(eles) {
                                for (var i = 0, l = eles.length; i < l; i++) {
                                    var e = eles[i];
                                    if (e.group() === 'nodes') {
                                        var position = e.position();
                                        me.setVertexCoords(e.id(), position.x, position.y);
                                    }
                                }
                                me.addActionStack();
                                me.centerNetwork();
                            }
                        });
                        break;
                    default:
                        console.log(dot);
                        break;
                }
            }
        },
        handleForceDirectedConfig: function(e) {
            var me = this;
            var clientRect = this.$.networkLayout.getBoundingClientRect();
            var width = (clientRect.width == 0) ? window.innerWidth : clientRect.width;
            var height = (clientRect.height == 0) ? window.innerHeight : clientRect.height;

            GraphLayout.force({
                network: this,
                width: width,
                height: height,
                linkDistance: parseFloat(e.detail.linkDistance),
                linkStrength: parseFloat(e.detail.linkStrength),
                charge: parseFloat(e.detail.charge),
                attributes: {
                    linkDistance: e.detail.linkDistanceAttribute,
                    linkStrength: e.detail.linkStrengthAttribute,
                    charge: e.detail.chargeAttribute
                },
                friction: parseFloat(e.detail.friction),
                gravity: parseFloat(e.detail.gravity),
                chargeDistance: parseFloat(e.detail.chargeDistance),

                simulation: false,
                end: function(verticesArray) {
                    for (var i = 0, l = verticesArray.length; i < l; i++) {
                        var v = verticesArray[i];
                        var vertex = me.graph.getVertexById(v.id);
                        vertex.position.x = v.x;
                        vertex.position.y = v.y;
                        vertex.renderer.move();
                        me._updateEdgeCoords(vertex);
                    }
                }
            });
        },
        handleCoseConfig: function(e) {
            var me = this;
            var clientRect = this.$.networkLayout.getBoundingClientRect();
            var width = (clientRect.width == 0) ? window.innerWidth : clientRect.width;
            var height = (clientRect.height == 0) ? window.innerHeight : clientRect.height;

            var config = {
                network: me,
                width: width,
                height: height - 100,
                end: function(eles) {
                    for (var i = 0, l = eles.length; i < l; i++) {
                        var e = eles[i];
                        if (e.group() === 'nodes') {
                            var position = e.position();
                            me.setVertexCoords(e.id(), position.x, position.y);
                        }
                    }
                    me.addActionStack();
                }
            };
            for (var key in e.detail) {
                config[key] = e.detail[key];
            }
            GraphLayout.cose(config);
        },
        handleConcentricConfig: function(e) {
            var me = this;
            var clientRect = this.$.networkLayout.getBoundingClientRect();
            var width = (clientRect.width == 0) ? window.innerWidth : clientRect.width;
            var height = (clientRect.height == 0) ? window.innerHeight : clientRect.height;
            var config = {
                network: me,
                width: width,
                height: height - 100,
                end: function(eles) {
                    for (var i = 0, l = eles.length; i < l; i++) {
                        var e = eles[i];
                        if (e.group() === 'nodes') {
                            var position = e.position();
                            me.setVertexCoords(e.id(), position.x, position.y);
                        }
                    }
                    me.addActionStack();
                }
            };
            for (var key in e.detail) {
                config[key] = e.detail[key];
            }
            GraphLayout.concentric(config);
        },
        select: function(option) {
            switch (option) {
                case 'All nodes':
                    this.selectAllVertices();
                    break;
                case 'All edges':
                    this.selectAllEdges();
                    break;
                case 'Everything':
                    this.selectAll();
                    break;
                case 'First neighbour nodes':
                    this.selectVerticesNeighbour();
                    break;
                case 'Invert node selection':
                    this.selectVerticesInvert();
                    break;
                case 'Adjacent edges':
                    this.selectEdgesNeighbour();
                    break;
                default:
                    console.log(option + " not defined");
            }
        },
        exportGraph: function(separator) {
            return this.graph.getAsSIF(separator);
        },
        exportVertexAttributes: function(separator) {
            return this._getAttributesAsFile(this.vertexColumns, this.vertices, separator);
        },
        exportEdgeAttributes: function(separator) {
            return this._getAttributesAsFile(this.edgeColumns, this.edges, separator);
        },
        exportBackground: function() {
            return JSON.stringify(this.backCanvas);
        },
        exportVisualSettings: function() {
            return JSON.stringify({
                vertexDefaults: this.vertexDefaults,
                edgeDefaults: this.edgeDefaults,
                vertexVisualSets: this.vertexVisualSets,
                edgeVisualSets: this.edgeVisualSets
            });
        },
        _getAttributesAsFile: function(columns, items, separator) {
            if (!separator) {
                separator = '\t';
            }
            // Attribute names
            var text = '';
            var lc = columns.length
            text += '#';
            for (var i = 0; i < lc; i++) {
                var attrName = columns[i].name;
                text += attrName + separator;
            }
            text += '\n';
            var item, attr;
            for (var i = 0, l = items.length; i < l; i++) {
                item = items[i];
                for (var j = 0; j < lc; j++) {
                    var column = columns[j];
                    if (column.name == 'x' || column.name == 'y') {
                        if (column.name == 'y') {
                            text += (item.position[column.name].toFixed(2) * -1) + separator;
                        }
                        if (column.name == 'x') {
                            text += item.position[column.name].toFixed(2) + separator;
                        }
                    } else {
                        if (item.attributes[column.name] != null) {
                            text += item.attributes[column.name] + separator;
                        } else {
                            text += "" + separator;
                        }
                    }
                }
                text += '\n';
            }
            return text;
        },
        setGraph: function(graph) {
            this.refreshGraphView(graph);
            this._createAttrColumns();
            this.graph.load(graph);
        },
        refreshGraphView: function(graph, keepTranslate) {
            if (graph == null) {
                graph = this.graph;
            }

            this.$.networkLayout.removeDom();
            this.$.networkLayout.clean(keepTranslate);

            var edges = graph.edges;
            var vertices = graph.vertices;
            for (var i = 0, l = vertices.length; i < l; i++) {
                var vertex = vertices[i];
                vertex.attributes.id = vertex.id;
                if (vertex.attributes.name == null) {
                    vertex.attributes.name = vertex.id;
                }
                //                    vertex.setRenderer(new CircosVertexRenderer(this.vertexDefaults));
                vertex.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            }
            for (var i = 0, l = edges.length; i < l; i++) {
                var edge = edges[i];
                edge.attributes.id = edge.id;
                if (edge.attributes.relation == null) {
                    edge.attributes.relation = edge.relation;
                }
                if (edge.attributes.name == null) {
                    edge.attributes.name = edge.id;
                }
                //                    edge.setRenderer(new DefaultEdgeRenderer(this.edgeDefaults));
                edge.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            }

            this.$.networkLayout.appendDom();
        },
        importVertexAttributeManager: function(columns, attributes) {
            for (var i = 0; i < columns.length; i++) {
                var column = columns[i];
                if (column.name == 'id') {
                    column.editable = false;
                }
                if (column.name == 'x' || column.name == 'y') {
                    column.formula = function(row) {
                        return parseFloat(row.position[this.name].toFixed(2));
                    }
                    column.editFormula = function(row, newVal) {
                        row.position[this.name] = parseFloat(newVal);
                        me.setVertexCoords(row.id);
                    }
                    column.width = 50;
                } else {
                    column.formula = function(row) {
                        return row.attributes[this.name];
                    }
                    column.editFormula = function(row, newVal) {
                        row.attributes[this.name] = newVal;
                    }
                    column.width = 100;
                }
            }

            var xyModifiedFlag = false;
            for (var i = 0; i < attributes.length; i++) {
                var row = attributes[i];
                var vertex = this.graph.getVertexById(row.id);
                if (vertex) {
                    for (key in row) {
                        if (key == 'x' || key == 'y') {
                            xyModifiedFlag = true;
                            var value = parseFloat(row[key]);
                            if (!isNaN(value)) {
                                if (key == 'x') {
                                    vertex.position[key] = value;
                                }
                                if (key == 'y') {
                                    vertex.position[key] = value * -1;
                                }
                            }
                        } else {
                            vertex.attributes[key] = row[key];
                        }
                    }
                }
            }

            this._addColumns(columns, 'vertexColumns');

            if (xyModifiedFlag) {
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    var vertex = this.graph.vertices[i];
                    vertex.renderer.move();
                    this._updateEdgeCoords(vertex);
                }
                this.centerNetwork();
            }

            this.fire('importnodeattr');
            //            this.$.nodeRender.refreshAttributes();

            // this.handleVertexDefaultXAttribute();
            // this.handleVertexDefaultYAttribute();
        },
        _getNewColumns: function(newColumns, columns) {
            var found;
            var columnsToAdd = [];
            for (var i = 0; i < newColumns.length; i++) {
                var newColumn = newColumns[i];
                found = false;
                for (var j = 0; j < columns.length; j++) {
                    var column = columns[j];
                    if (newColumn.name === column.name) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    columnsToAdd.push(newColumn);
                }
            }
            return columnsToAdd;
        },
        _addColumns: function(newColumns, path) {
            var toAddColumns = this._getNewColumns(newColumns, this[path]);
            this.set(path, this[path].concat(toAddColumns));
        },
        addVertexColumns: function(newColumns) {
            this._addColumns([].concat(newColumns), 'vertexColumns');
        },
        addEdgeColumns: function(newColumns) {
            this._addColumns([].concat(newColumns), 'edgeColumns');
        },
        importEdgeAttributeManager: function(columns, attributes) {
            for (var i = 0; i < columns.length; i++) {
                var column = columns[i];
                if (column.name == 'id') {
                    column.editable = false;
                }
                column.formula = function(row) {
                    return row.attributes[this.name];
                }
                column.editFormula = function(row, newVal) {
                    row.attributes[this.name] = newVal;
                }
                column.width = 100;
            }
            for (var i = 0; i < attributes.length; i++) {
                var row = attributes[i];
                var edge = this.graph.getEdgeById(row.id);
                if (edge) {
                    for (key in row) {
                        edge.attributes[key] = row[key];
                    }
                }
            }
            this._addColumns(columns, 'edgeColumns');
            this.fire('importedgeattr');
            //            this.$.edgeRender.refreshAttributes();
        },
        __iliketomoveit: function() {
            this.setLayout('Force directed (simulation)');
        },
        handleLoadExampleMenu: function(e) {
            var me = this;
            if (e.detail.subvalue == 1) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                };
                request.open('GET', './example-files/ppi_histone_network.json.gz', true);
                request.send();
            }
            if (e.detail.subvalue == 2) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                    me.centerNetwork();
                    // me.setLayout("Force directed");
                };
                request.open('GET', './example-files/RAF_MAK_kinase_cascade.json.gz', true);
                request.send();
            }
            if (e.detail.subvalue == 3) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                    me.setLayout("Force directed");
                };
                request.open('GET', './example-files/mutational_landscape_oncogenes_and_tumor_suppressors.json.gz', true);
                request.send();
            }
            if (e.detail.subvalue == 4) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                    me.setLayout("Force directed");
                };
                request.open('GET', './example-files/ppi_network.json.gz', true);
                request.send();
            }
        },
        loadSif: function(sifString) {
            var graph;
            new SIFNetworkDataAdapter({
                async: false,
                dataSource: new StringDataSource(sifString),
                handlers: {
                    'data:load': function(event) {
                        graph = event.graph;
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.setGraph(graph);
        },
        loadText: function(textString, sourceCol, targetCol, relationCol, relationDefaultName) {
            var graph;
            new TextNetworkDataAdapter({
                async: false,
                dataSource: new StringDataSource(textString),
                handlers: {
                    'data:load': function(event) {
                        var adapter = event.sender;
                        graph = adapter.parseColumns(sourceCol, targetCol, relationCol, relationDefaultName);
                        // graph = adapter.parseColumns(0, 1, -1, "r");
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.setGraph(graph);
        },
        loadNodeAttributes: function(attrString, useFirstLineAsColumnNames) {
            var e;
            new AttributeNetworkDataAdapter({
                async: false,
                useFirstLineAsColumnNames: useFirstLineAsColumnNames,
                dataSource: new StringDataSource(attrString),
                handlers: {
                    'data:load': function(event) {
                        e = event;
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.importVertexAttributeManager(e.columns, e.attributes);
        },
        loadEdgeAttributes: function(attrString, useFirstLineAsColumnNames) {
            var e;
            new AttributeNetworkDataAdapter({
                async: false,
                useFirstLineAsColumnNames: useFirstLineAsColumnNames,
                dataSource: new StringDataSource(attrString),
                handlers: {
                    'data:load': function(event) {
                        e = event;
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.importEdgeAttributeManager(e.columns, e.attributes);
        },
        loadBackground: function(backgroundString) {
            var me = this;
            this.backCanvas.loadFromJSON(JSON.parse(backgroundString), function(e) {
                me.backCanvas.renderAll();
                me.saveLocalStorage();
            });
        },
        loadVisualSettings: function(settingsString) {
            var me = this;
            var o = JSON.parse(settingsString);

            this.vertexDefaults = o.vertexDefaults;
            this.edgeDefaults = o.edgeDefaults;
            this.vertexVisualSets = o.vertexVisualSets;
            this.edgeVisualSets = o.edgeVisualSets;

            this.refreshGraphView();

            this.saveLocalStorage();
        },
        applyVisualSets: function() {
            this.$.nodeRender.applyVisualSets();
            this.$.edgeRender.applyVisualSets();
        }
    });
</script>
